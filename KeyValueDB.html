<!DOCTYPE html><html lang=sk><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Xss-Protection content="1; mode=block"><meta http-equiv=X-Content-Type-Options content=nosniff><meta name=viewport content="width=device-width, initial-scale=1"><link rel=alternate type=application/rss+xml title="RSS Feed" href=feed.rss><meta name=author content=harrison314><meta name=generator content=AspNetStatic><title>Ako na Key-Value datab&#xE1;zu</title><meta property=og:title content="Ako na Key-Value databázu"><meta property=og:description content="Ukážka modelovania v key-value databázach."><meta property=og:url content=https://harrison314.github.io/KeyValueDB.html><meta property=og:image content=https://harrison314.github.io/images/KeyValueDB/media.png><meta name=description content="Ukážka modelovania v key-value databázach."><link href=css/bootstrap.min.css rel=stylesheet><link href=css/blog-post.css rel=stylesheet><script type=text/x-mathjax-config>
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel=stylesheet href=css/Highiler/vs.css><style>img{max-width:100%}.img-center{display:block;margin-left:auto;margin-right:auto}</style><body><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a class=navbar-brand href=index.html>harrison314 blog</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=/All.html>Obsah</a><li><a href=/DevelopingAll.html>Programovanie</a><li><a href=/GeneralAll.html>Všeobecné</a><li><a href=/OMne.html>O mne</a></ul></div></div></nav><div class=container><div class=row><div class="col-lg-8 col-md-8"><h1>Ako na Key-Value datab&#xE1;zu</h1><div class=publishDate>M&#xE1;j 2023</div><p>Už nejakú dobu sa zaoberám databázami a&#160;nejaký čas som riešil aj&#160;vlastné nerelačné úložisko. V&#160;tomto blogu chcem zosumarizovať postupy, ako vyriešiť niektoré úlohy pomocou generickej key-value databázy, aj&#160;keď mnohé z&#160;nich pôsobia dojmom „samozrejmosti“.<p>Pre implementáciu key-value databáz sa najčastejšie používajú <em>B+ stromy</em>, <em>sorted string tabulky</em> (s <em>LSM tree</em>), prípadne <em>skip-list</em>. Všetky tieto implementácie umožňujú nájsť veľmi rýchlo nasledujúci kľúč (v istom zoradení) alebo&#160;hľadať podľa prefixu či&#160;rozsahu a&#160;to je v&#160;mnohých nasledujúcich riešeniach potrebné. Databázy založené na&#160;<em>hash mapách</em> túto možnosť zvyčajne nemajú.<p><em>V nasledujúcom texte používam syntax, kde&#160;<code>key =&gt; value</code> znamená kľúčový pár, ktorý&#160;sa uloží v&#160;databáze, zátvorky znamenajú N-ticu (binárne serilzovanú N-ticu hodnôt, kde&#160;<code>(a, b, c)</code> má prefix <code>(a, b)</code>) a&#160;v jednoduchých úvodzovkách sú konštanty. Nasledujúci text vyžaduje aj&#160;základné znalosti z&#160;relačných databáz.</em><h2 id=pouzitie-prefixov>Použitie prefixov</h2><p>Použitie prefixov kľúčov je základný koncept na&#160;oddeľovanie logických celkov v&#160;key-value databázach napríklad na&#160;určenie typu záznamu, prípade k&#160;príslušnosti k&#160;inej entite.<div class="lang-handlebars editor-colors">('data', 'user', user_Id, 'Address') => user address data</div><p>Takéto usporiadane kľúča hovorí, že&#160;sa jedná o&#160;dáta (nie index, ani&#160;iné pomocné štruktúry) pre&#160;používateľa s&#160;<code>user_id</code> a&#160;položku <code>Address</code>.<p>Následne je možné vymazať všetky údaje k&#160;danému používateľovi podľa prefixu <em>id</em> používateľa.<p>Samozrejme veľkosť kľúča je vhodné udržiavať v&#160;rozumnej miere.<h2 id=modelovanie-tabuliek>Modelovanie tabuliek</h2><p>Tabuľky (alebo aj&#160;<em>column family</em> či&#160;<em>wide-column</em> prístup) ide riešiť dvoma spôsobmi. Prvý je taký, že&#160;sa použije primárny kľúč ako kľúč, a&#160;riadok tabuľky sa serializuje a&#160;uloží, ako binárna hodnota.<div class="lang-handlebars editor-colors">('table', table_name, id) => (id, given name, surname, date of brith)</div><p>No v&#160;tomto prípade nie je možné pracovať so&#160;samostatnými hodnotami.<p>Druhý spôsob je ukladania ukladá hodnoty samostatne a&#160;je možné s&#160;nimi samostatne pracovať bez&#160;deserilizácie a&#160;serializácie (napríklad ich atomicky inkrementovať alebo&#160;vyťiahnuť).<div class="lang-handlebars editor-colors">('table', table_name, id, 'given name') => given name ('table', table_name, id, 'surname') => surname ('table', table_name, id, 'date of brith') => date of brith</div><h2 id=modelovanie-vektorov>Modelovanie vektorov</h2><p>S modelovaním vektorov je to podobné ako s&#160;modelovaním tabuliek. Buď&#160;ho uložíme serializovaný alebo&#160;po jednotlivých hodnotách, aby&#160;s nimi bolo možné pracovať samostatne, či&#160;vytiahnuť si len časť vektoru.<div class="lang-handlebars editor-colors">('vector', vector_name, id) => (value_1, value_2, value_3,&#8230;)</div><p>A druhá varianta.<div class="lang-handlebars editor-colors">('vector', vector_name, id, index_i) => value_i</div><h2 id=modelovanie-grafu>Modelovanie grafu</h2><p>Graf sa skladá z&#160;vrcholov a&#160;hrán medzi vrcholmi. V&#160;key-value databáze sa modelujú tak, že&#160;vrcholy sú klasické hodnoty so&#160;svojim <em>id</em>.<div class="lang-handlebars editor-colors">('graph', graph_id, 'edge', edge_id) => edge data</div><p>Orientované hrany majú v&#160;kľúči <em>id</em> vrcholu z&#160;ktorého vychádzajú do, ktorého vchádzajú a&#160;váhy majú v&#160;hodnote.<div class="lang-handlebars editor-colors">('graph', graph_id, 'vertice', edge_from_id, edge_to_id) => vertice data</div><p>Ak má graf podporovať viacnásobné hrany je ešte&#160;pridané <em>id</em> pre&#160;samotnú hranu.<p>Pri traverzovaní grafom sa ku&#160;aktuálnemu uzlu získajú hrany tak, že&#160;sa vyhľadajú podľa prefixu z&#160;<em>id</em> aktuálneho uzlu.<h2 id=indexovanie>Indexovanie</h2><p>Indexovanie je spôsob ako uložiť dodatočné informácie tak, aby&#160;urýchlili vyhľadávanie a&#160;nebolo nutné aby&#160;databáza prešla cez všetky dáta. Keďže key-value databázy zvyčajne nemajú sekundárne indexy je ich potrebné modelovať inak.<p>Princíp modelovania indexov je jednoduchý, tiež využíva to, že&#160;je možné hľadať podľa prefixu.<p>Ak hodnotu, ktorú indexujeme <code>val1</code>, ktorá sa nachádza v&#160;hodnote s&#160;<em>id</em>, vytvoríme takýto záznam:<div class="lang-handlebars editor-colors">('ix', index_name, val1) => id</div><p>Tak získame unikátny index, no&#160;ak chceme indexovať opakujúce sa hodnoty, tak musím do&#160;kľúča pridať niečo unikátne a&#160;tu sa rovno ponúka použiť <em>id</em> a&#160;hodnotu necháme prázdnu.<div class="lang-handlebars editor-colors">('ix', index_name, val1, id) => Ø</div><p>A tento koncept môžeme ďalej rozširovať. Napríklad do&#160;hodnoty vložiť vybrané dáta s&#160;indexovaného záznamu (v SQL svete sú to <em>included columns</em>).<div class="lang-handlebars editor-colors">('ix', index_name, val1, id) => (included columns, &#8230;)</div><p>Poprípade vytvoriť zložený index, kde&#160;sa indexujú viaceré hodnoty.<div class="lang-handlebars editor-colors">('ix', index_name, val1, val2, id) => Ø</div><p>Takýto zložený index má rovnaké obmedzenie ako v&#160;relačných databázach a&#160;to, že&#160;samostatne ide vyhľadávať iba podľa prvej hodnoty, ale&#160;podľa druhej hodnoty samostatne už nie.<h2 id=modelovanie-casovych-radov>Modelovanie časových radov</h2><p>Časové rady (<em>time series</em>) tvoria hodnoty, ktoré sú usporiadané v&#160;čase, ich hodnota je tvorená zvyčajne premennými/vlastnosťami. V&#160;key-value databázach idú modelovať rôznymi spôsobmi podľa toho ako ich chceme použiť.<p>Asi najpriamočiarejšie je ako časový údaj použiť rovno timestamp (v milisekndách), vtedy ide vyhľadávať podľa konkrétnych časových údajov. Prípade do&#160;kľúča zahrnúť <em>id</em> zdaroja, podľa ktorého chceme filtrovať.<div class="lang-handlebars editor-colors">('timeserie', timeserie_name, timestamp) => (values,&#8230;)</div><div class="lang-handlebars editor-colors">('timeserie', timeserie_name, timestamp, source_id) => (values,&#8230;)</div><p>Ak ale&#160;chceme vyťahovať hodnoty podľa určitých časových období, tak si timestamp rozdelíme na&#160;„ľudské“ údaje ako rok, kvartál, mesiac, deň,&#8230; tak ide vytiahnuť údaje napríklad pre&#160;konkrétny mesiac.<div class="lang-handlebars editor-colors">('timeserie', timeserie_name, year, month, day, hout, minute, sec, milisec) => (values,&#8230;)</div><p>Tento model počíta s&#160;tým, že&#160;v rovnakom čase bude zaznamenaný len jedna hodnota. Ak ich chceme viac musíme kľúč nejakým spôsobom zunikátniť (napríklad priďať za&#160;čas náhodné dáta).<h2 id=ukladanie-blob-ov>Ukladanie BLOB-ov</h2><p><em>BLOB</em> (<em>Binary large object data</em>) je proste hocaký blok binárnych dát alebo&#160;súbor. Pri&#160;key-value databázach ho teoreticky môžeme uložiť ako jednu hodnotu, no&#160;pri takom prístupe narážame na&#160;maximálnu veľkosť akú je možné uložiť do&#160;jednej hodnoty. Taktiež je takto problém tieto dáta vytiahnuť. Pre&#160;to je lepšie ich uložiť po&#160;malých kúskoch, ktoré sa očíslujú.<div class="lang-handlebars editor-colors">('blob', blob_name, 'content', 0) => chunk ('blob', blob_name, 'content', 1) => chunk ('blob', blob_name, 'content', 2) => chunk ('blob', blob_name, 'content', 3) => chunk ('blob', blob_name, 'content', 4) => chunk &#8230; ('blob', blob_name, 'content', N-1) => chunk</div><p>A nakoniec ako poslednú hodnotu pridáme informácie o&#160;<em>BLOB-e</em>.<div class="lang-handlebars editor-colors">('blob', blob_name, 'info') => (chunkCount: N, size: 1024, chunkSize: 512, name: foobar.pdf)`</div><p>To umožní hľadať len kompletne nahrané <em>BLOB-y</em>. Je možné celý zmazať podľa prefixu. A&#160;aj vytiahnuť konkrétnu časť, lebo&#160;kúsky (chunk-y) majú rovnakú veľkosť (až na&#160;posledný).<h2 id=spatial-index>Spatial index</h2><p>Spatial index, alebo&#160;aj priestorový index je index, pomocou ktorého ide efektívne vyhľadávať v&#160;priestorových dátach (body, geometrické a&#160;geografické útvary,&#8230;). Typickou úlohou pre&#160;tento index je nájsť body do&#160;určitej vzdialenosti od&#160;iného bodu.<p>V <em>MS SQL</em> je spatial index implementovaný pomocou toho, že&#160;priestor sa rozdelí na&#160;hierarchickú mriežku, ktorú ide prehľadať podobným princípom ako strom. No&#160;v key-value databáze sa používa iný postup – dvojrozmerné body v&#160;priestore sa prevedú na&#160;jednorozmernú veličinu, ktorá má tú vlastnosť, že&#160;blízke hodnoty tejto veličiny implikujú blízkosť pôvodných bodov v&#160;dvojrozmernom priestore. Používa sa na&#160;to <a href=https://cs.wikipedia.org/wiki/Morton%C5%AFv_rozklad>Mortonov rozklad</a> (<em>Morthon Z-curve</em>, <em>Z-curve order</em>).<p>Pri priestorových útvaroch je treba každý bod tohto útvaru indexovať samostatne.<p>V key-value databázy budeme tento index modelovať nasledovne (pre objekt s&#160;<em>id</em>):<div class="lang-handlebars editor-colors">('ixs', index_name, z_order_value, id) => (x,y)</div><p>Hodnotu Mortnovho rozkladu získame použitím vhodného zaokrúhlenia a&#160;levelu súradníc a&#160;pomocou knižnice vypočítame jeho hodnotu (pre .Net to môže byť napríklad <a href=https://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Shape.Fractal.MortonCode.html>NetTopologySiute</a>). V&#160;hodnote indexu sú uvedené pôvodné súradnice aby&#160;bolo možné jednoducho zistiť, či&#160;vyhovujú zadanej podmienke v&#160;dopyte. Pomocou Mortnovho rozkladu sa zistí aký&#160;rozsah hodnôt sa bude hľadať zo&#160;zdaného bodu a&#160;vyhľadávanej oblasti. Ten sa v&#160;key-value databázy vyhľadá a&#160;spracujú sa ich pôvodné hodnoty.<h2 id=zaver>Záver</h2><p>Pomocou key-value databázy ide modelovať mnoho spomenutých vecí. Ktoré sa môžu hodiť, pretože&#160;tieto databázy často umožňujú jednoduchú replikáciu a&#160;horizontálne škálovanie.<p>Pomocou konkrétnych databáz ide implementovať aj&#160;iné dátové modely, ale&#160;je pre&#160;ne potrebná dodatočná funkcionalita, napríklad pre&#160;frontu správ je potrebná atomická funkcia na&#160;zmenu hodnoty pre&#160;kľúč (napríklad implementovaná pomocou <em>change-vektora</em> alebo&#160;kontroly verzie hodnoty).<p>Pri písaní tohto blogu som čerpal hlavne z&#160;tutoriálov ku&#160;<a href="https://www.foundationdb.org/">FoundationDb</a>, ktorá sa používa ako &quot;podvozok&quot; pre&#160;distribuované databázové systémy.</div><div class="col-lg-4 col-md-4 hidden-xs hidden-sm"><div class=well><h4>V&#xFD;voj</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/ModerneHtml.html>Renderova&#x165; HTML na serveri nie je hanba</a><li><a href=/InterpolatedStringAsHtmlTemplate.html>Interpolated strings ako HTML &#x161;abl&#xF3;na</a><li><a href=/PqcCert.html>Hybridn&#xE9; certifik&#xE1;ty v C#</a><li><a href=/1brc.html>One Billion Rows Challenge</a><li><a href=/MigraciaBlogu.html>Migr&#xE1;cia blogu</a><li><a href=/PostKvantovaKryptografia.html>Post-kvantov&#xE1; kryptografia v C#</a><li><a href=/BouncyHsm.html>Ako som robil BouncyHsm</a><li><a href=/BuildAutomation.html>Pre&#x10D;o pou&#x17E;&#xED;va&#x165; build automation</a><li><a href=/KeyValueDB.html>Ako na Key-Value datab&#xE1;zu</a><li><a href=/RankFunctions.html>MS SQL a RANK funkcie</a><li><a href=/DevelopingAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>V&#x161;eobecn&#xE9;</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/EzoGenerator.html>Gener&#xE1;tor Ezo textov</a><li><a href=/AlternativnyRecept.html>Propag&#xE1;cia alternat&#xED;vnej medic&#xED;ny</a><li><a href=/VotrelciDavnoveku.html>Votrelci d&#xE1;vnoveku</a><li><a href=/GeneralAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>O mne</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/VyvojarskeOdkazy.html>Moje vyvojarske blogy</a><li><a href=/OMne.html>O mne</a><li><a href=/OMneOdkazy.html>Moja tvorba inde</a><li><a href=/Portfolio.html>Portólio</a></ul></div></div></div></div></div><hr><footer><div class="row no-print"><div class="col-lg-8 col-sm-8"><div class=well><h4>Našli ste chybu, alebo chcete niečo doplniť?</h4><p>Ak ste našli chybu v článu, chcete niečo dopniť, alebo sa vyjadriť k téme, môžete na <a href="https://github.com/harrison314/harrison314.github.io/issues/new?title=Ako%20na%20Key-Value%20datab%C3%A1zu&amp;body=https%3A%2F%2Fharrison314.github.io%2FKeyValueDB.html" target=_blank>Githube otvoriť issue</a>.</div></div></div><div class=row><div class=col-lg-12><p>Copyright &copy; harrison314 2013<span class=on-print> - https://harrison314.github.io/</span></div></div></footer></div><script src=js/jquery.js></script><script src=js/bootstrap.min.js></script>