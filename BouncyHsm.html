<!DOCTYPE html><html lang=sk><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Xss-Protection content="1; mode=block"><meta http-equiv=X-Content-Type-Options content=nosniff><meta name=viewport content="width=device-width, initial-scale=1"><link rel=alternate type=application/rss+xml title="RSS Feed" href=feed.rss><meta name=author content=harrison314><meta name=generator content=AspNetStatic><!--Blazor:{"type":"server","prerenderId":"7f4a10cf9c9f476a88776d90ab3c99ce","key":{"locationHash":"77D12F14A8105320B1AAED6AE7E689DA0EC4483270A645E84079EAA0FFDF550D:5","formattedComponentKey":""},"sequence":0,"descriptor":"CfDJ8G7p01mvTipOj9seX7mukmuI7DKf0K7NLDapewFjCB5y4RG6ktwEheuvMYZZJd8zKNRIKvePRhSfFNrBreCGbT9/Xq/4ZH48ZUSWFQFn3wnQ7w2W8I\u002BdRuPZmEfTOU/xJLITRHFjYx65GI1PBxmTkKu8OcJVQR73stcPg/29tU6fMxWD5xdsGEIu1IH8FamxDUm5M83w3flAE2lIixkjazrYRKwJ782bGefjg23HVAHBUqQMzLFYVJlybyUQlnpnBz7QuMq/uT1ZKk8JORjzJt9u\u002BY3uMO/t\u002B5OgkPYnSGYo5Dvy4E/Pql9B3ntps6nMYcQQKJD5ehjsz0GAcPLHjEcB4qxvEb5sw8lIY7Kod8kiHkaGzz3AGZsRnc7VSIeqcCLMfsIz6DxU5cLJjMFFJg\u002BsnZXt\u002BDhnzUFDDRlEY6nLCpK2xovHxynixGr7cer1iKKjyophFMf7LgAfbAmA1vpV5yBwI9D2WFjm7y4fmVY0P5LBP8IAs0vkUAynaWMDlZlWe/9Xw\u002BzmjdjGQLoGipuPJnvHiB95TMz2uxxdY3G461ph5/yPW3Gahwr1qhTItjfdIvhNonHnvmkhCwCOHUk="}--><title>Ako som robil BouncyHsm</title><meta property=og:title content="Ako som robil BouncyHsm"><meta property=og:description content="Dôvody, návrh architektúry a vývoj simulátoru HSM a čipových kariet s PKCS#11 rozhraním v .NET-e a Blazore."><meta property=og:url content=https://harrison314.github.io/BouncyHsm.html><meta property=og:image content=https://harrison314.github.io/images/BouncyHsm/media.png><meta name=description content="Dôvody, návrh architektúry a vývoj simulátoru HSM a čipových kariet s PKCS#11 rozhraním v .NET-e a Blazore."><!--Blazor:{"prerenderId":"7f4a10cf9c9f476a88776d90ab3c99ce"}--><link href=css/bootstrap.min.css rel=stylesheet><link href=css/blog-post.css rel=stylesheet><script type=text/x-mathjax-config>
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel=stylesheet href=css/Highiler/vs.css><style>img{max-width:100%}.img-center{display:block;margin-left:auto;margin-right:auto}</style><body><!--Blazor:{"type":"server","prerenderId":"ee6aa1d8d2e142b78cfc5fb6eeac1ab6","key":{"locationHash":"E66163C4CFF76A7FA22AAEDA8B754AB10710C0C1D42652E9DDB330204231FE18:11","formattedComponentKey":""},"sequence":1,"descriptor":"CfDJ8G7p01mvTipOj9seX7mukmto1J12sx0sM6iccs/1g1\u002BEpnueXfOyCar3Jn4Y57sf10Jj5yO/KAImDO1wxb0ybP5N1oWz887YJjuLZ8O8LuimQeV3jdqWlMAcSBcUDLxGWe4L8leDvbcaz/3FdeTFNimvJXzlwHJBZJGaur308DGE4vEqasvY6/uYY3LeAsjVH611ZUBoqH\u002BCSUzXLX5iI2QL5l8Z9SfaVE/QDriBP/Cu4TCchaPH0QNl2/aGG8oceiMwRCgGFncD7ELydmrxbpTVYFjMahVv7Yv2RuT04tS78r6b1R1nru7X7r7xXeFKAvc/4eQpsO3cjHWxOkPeoV\u002BZkwk\u002B1NoCqAgKohIvKUebAvAmrV\u002BDDUrQK0Cu97pLMgIRD7xXq6X8R5ZfdmVL/53G4OL7uGPxoqajwG5psooKpqiDZQPVoZ2GLBfhzMJsUenQObjjyBvppNAQOS1eQgQPLzaLJYHgsfH1aGEZM6CynszAOVob8JTeN0dAMoyF0nX05aqW67uGpbnqSAw0Qw9/vIRl5W0Uh\u002BfWgygNhYsi"}--><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a class=navbar-brand href=index.html>harrison314 blog</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=/All.html>Obsah</a><li><a href=/DevelopingAll.html>Programovanie</a><li><a href=/GeneralAll.html>Všeobecné</a><li><a href=/OMne.html>O mne</a></ul></div></div></nav><div class=container><div class=row><div class="col-lg-8 col-md-8"><h1>Ako som robil BouncyHsm</h1><div class=publishDate>November 2023</div><p>V tomto článku popisujem, ako som robil softvérovú implementáciu HSM-ka (<em>hardware security module</em>), dôvody prečo som sa rozhodol pustiť do&#160;projektu, ktorý&#160;takmer nik nevyužije, návrhu architektúry, komunikačného protokolu a&#160;slepých uličiek, a&#160;nakoniec, ako sa vďaka tomu stal kontribútorom <a href=https://github.com/bcgit/bc-csharp>BouncyCastle</a>.<p>Začalo to tak, že&#160;som chcel spraviť prototyp systému, ktorý&#160;dokáže overiť TOTP (<em><a href=https://www.rfc-editor.org/rfc/rfc6238>Time-based one-time password</a></em>) bezpečne, to znamená, že&#160;zdieľané tajomstvo nebude v&#160;čitateľnej podobe ani&#160;v databáze ani&#160;v RAM služby (ako obrana voči memory dumpu) Chcel som na&#160;to využiť HSM a&#160;jeho existujúci simulátor <em>SoftHSMv2</em>, ale&#160;ten nemal podporu potrebných mechanizmov (algoritmov). Vtedy mi došla trpezlivosť a&#160;začal som rozmýšľať ako to vyriešiť.<p>Výsledkom je <a href=https://github.com/harrison314/BouncyHsm>BouncyHsm</a>.<h2 id=hsm-pkcs11>HSM, PKCS#11</h2><p>Najskôr trochu nevyhnutnej teórie&#8230;<p>HSM je <em>hardware security module</em> – ide o&#160;hardvérové zariadenie, ktoré slúži na&#160;krytografické operácie a&#160;uchovávanie privátnych kľúčov a&#160;tajomstiev. Používa sa pre&#160;to, že&#160;z neho nejde získať privátne kľúče softvérovo ani&#160;mechanicky, a&#160;chráni pred ich únikom aj&#160;v prípade chyby softvéru, aj&#160;v prípade odcudzenia zariadenia, ale&#160;aj voči takým veciam ako kompromitácia ľudského faktoru (ak sa použije správne).<p>PKCS#11 je platformovo neutrálny štandard pre&#160;rozhranie pre&#160;prácu s&#160;kľúčmi na&#160;kryptografických hardvérových zariadeniach ako sú HSM-ká a&#160;čipové/smart karty (napríklad <em>Slovenské eID</em>). Ide o&#160;API cca. 65 C-éčkových funkcii (exportovaných DLL-kou) a&#160;k tomu konštanty a&#160;štruktúry. Toto API umožňuje manažment kľúčov a&#160;iných objektov, podporuje podpisovanie, šifrovanie, hašovanie,&#8230; Často umožňuje použitie RSA, eliptických kriviek, AES šifry, SHA-2 hash funkcií,&#8230; Čipové karty podporujú zvyčajne len podpisovanie, zatiaľ čo&#160;HSM-ká implementujú omnoho väčšiu časť štandardu.<p>PKCS#11 API má svoje špecifiká, napríklad aplikácia sa musí voči nemu autentifikovať (to sa z&#160;bezpečnostných dôvodov robí často ručne). Ide o&#160;C API, takže namiesto rozumnej chyby sa vracia len všeobecný chybový kód (niečo ako kategória chyby napr. <code>CKR_GENERAL_ERROR</code>, <code>CKR_ARGUMENTS_BAD</code>, <code>CKR_DEVICE_ERROR</code>, <code>CKR_PIN_INVALID</code>,&#8230;) a&#160;konkrétnu chybu treba nájsť v&#160;logoch obslužného softvéru (dalo by sa povedať ovládača/driveru). Ďalším špecifikom je, že&#160;ID-čka nie sú unikátne a&#160;viac objektov môže mať zhodné <code>CKA_ID</code>. Objekty sa vyhľadávajú len na&#160;presnú zhodu atribútov.<p>Pri vývoji je dobré mať možnosť používať softvérovú náhradu HSM alebo&#160;čipovej karty. HSM-ko je pomerne drahá záležitosť, ktorá je zložitá na&#160;administráciu, nejde pichnúť do&#160;notebooku, čo&#160;sa v&#160;čase COVID-u a&#160;homeofficov ešte&#160;skomplikovalo. Zas čipové karty sú kvôli obmedzenému hardvéru pomerne pomalé a&#160;majú obmedzený počet zápisov. Obe tieto technológie sa ťažko používajú v&#160;unit testoch (technicky sú to integračné testy), hlavne na&#160;virtuálnych serveroch.<h3 id=niektore-pojmy-z-pkcs11>Niektoré pojmy z&#160;PKCS#11</h3><ul><li><em>slot</em> – reprezentácia čítačky kariet,<li><em>token</em> – reprezentácia čipovej karty,<li><em>crypto objekt</em> – dátová štruktúra na&#160;PKCS#11 zariadení, napr. privátny kľúč, verejný kľúč, certifikát, dátový objekt,<li><em>atribút</em> – vlastnosť/property crypto objektu, každý tym crypto objektu má sadu predpísaných vlastností ako <code>CKA_ID</code>, <code>CKA_LABEL</code>, <code>CKA_EC_POINT</code>,&#8230;<li><em>privátny objekt</em> – objekt, ktorý&#160;ma nastavený atribút <code>CKA_PRIVATE</code> na&#160;<code>true</code> a&#160;je s&#160;ním možné pracovať až po&#160;prihlásení do&#160;tokenu,<li><em>senzitívny atribút</em> – atribút, ktorý&#160;nie je možné z&#160;objektu čítať (napr. hodnota privátneho kľúča),<li>mechanizmus – reprezentuje operáciu/algoritmus na&#160;PKCS#11 zariadení, napríklad vytvorenie kľúčového páru, typ podpisu (RSA Pkcs1, RSA pss, ECDSA), typ šifrovania (AES, RSA oaep),&#8230;</ul><h2 id=existujuce-riesenie-softhsmv2>Existujúce riešenie – SoftHSMv2</h2><p>Softvérová implementácia HSM-ka s&#160;PKCS#11 rozhraním už jestvuje, ide o&#160;<a href=https://github.com/opendnssec/SoftHSMv2>SohftHSMv2</a>. Niekoľko rokov som ho používal, ale&#160;postupne mi pretiekol pohár trpezlivosti.<p>SohftHSMv2 je implementovaný ako natívna knižnica s&#160;pár obslužnými programami.<p>Na aké problémy som s&#160;ním narazil:<ul><li>malé množstvo podporovaných algoritmov (narazil som keď&#160;som potreboval použiť <em>diffie hellman</em> s&#160;<em>KDF1</em>, alebo&#160;niektoré varianty AES-u),<li>podpora rôznych algoritmov na&#160;rôznych platformách (na <em>CentOs 7</em> podporuje inú sadu eliptických kriviek ako na&#160;<em>Debian 11</em>),<li>nefunkčné logovanie najmenej od&#160;roku 2017 (<a href=https://github.com/opendnssec/SoftHSMv2/issues/598>issue</a> + kody) – na&#160;Windowse od&#160;začiatku nefunguje logovanie do&#160;<em>EventLogu</em>, na&#160;linuxových systémoch zas musí logovanie povoliť integrujúca aplikácia do&#160;syslogu (logovanie je naozaj dôležité pri&#160;vývoji), a&#160;tieto problémy neboli doposiaľ opravené,<li>od roku 2020 je nefunkčné CI pre&#160;Windows,<li>tým, že&#160;ide len o&#160;knižnicu, tak si krypto objekty (kľúče) ukladá na&#160;súborový systém, to spôsobuje problémy, že&#160;keď chcem službe na&#160;testovacom prostredí pridať nové kľúče, tak ich nevidí, lebo&#160;je spustená pod iným používateľom a&#160;treba ručne „hekovať“ súbory kľúčov na&#160;disku,<li>ak vaša aplikácia používa inú verziu OpenSSL knižnice ako SoftHSM, pravdepodobne vám pri&#160;prvom volaní aplikácia padne,<li>problémové použitie pri&#160;unit/integračnom testovaní,<li>netriviálne použitie cez Docker,<li>komplikované použitie cez CMD nástroje (ja rád klikám).</ul><p><img src=images/BouncyHsm/image1.png class=img-center alt="Issue zo SoftHSMv2 - Building on Windows"><br> <img src=images/BouncyHsm/image2.png class=img-center alt="Issue zo SoftHSMv2 - OpenSSL problem"><br> <img src=images/BouncyHsm/image3.png class=img-center alt="Issue zo SoftHSMv2 - Another OpenSSL problem"><br> <img src=images/BouncyHsm/image4.png class=img-center alt="Issue zo SoftHSMv2 - CI is broken"><h2 id=poziadavky-na-bouncyhsm>Požiadavky na&#160;BouncyHsm</h2><p>BouncyHsm som sa rozhodol robiť pre&#160;to, aby&#160;som si vyriešil vyššie spomínané problémy a&#160;uľahčil si prácu. Taktiež som chcel dosiahnuť, aby&#160;výsledné riešenie bolo „developer frendly“ a&#160;ľahko sa nasadzovalo a&#160;používalo.<p>Ak som chcel vyriešiť vyššie spomínané problémy, tak od&#160;začiatku som vedel, že&#160;na kryptografické operácie použijem BouncyCastle, budem sa vyhýbať natívnym závislostiam, a&#160;že riešenie bude rozdelené na&#160;natívnu PKCS#11 knižnicu a&#160;.NET aplikáciu.<p>Z tohto všetkého vychádzajú nasledovné požiadavky:<ul><li>čo najväčšie množstvo kryptografických funkcií zo&#160;štandardu <em><a href=https://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/os/pkcs11-curr-v2.40-os.pdf>PKCS#11 v2.40</a></em>,<li>podpora Windowsu, Windows Serveru, niektorých linuxov,<li>podpora x86 a&#160;x64 architektúry,<li>rovnaké chovanie na&#160;rôznych platformách<li>podpora viac-aplikačného súbežného prístupu cez PKCS#11 knižnicu,<li>jednoduchá inštalácia (rozbalím archív a&#160;môžem používať),<li>natívna PKCS#11 knižnica bez&#160;závislostí na&#160;iných knižniciach (rieši to depenceny hell na&#160;linixe),<li>možnosť používať podpisový PIN (ako simuláciu čipových kariet),<li>bohaté logovanie na&#160;strane natívnej knižnice aj&#160;na strane samotnej aplikácie,<li>možnosť obísť PKCS#11 štandard:<ul><li>pozrieť sa na&#160;privátne kryto objekty,<li>pozrieť sa na&#160;senzitívne atribúty,<li>možnosť jednoducho importovať P12/PFX, privátny kľúč tak ako keby vznikol v&#160;HSM-ku,</ul><li>kvôli použiteľnosti v&#160;testoch mať možnosť ovládať BouncyHsm programovo,<li>mať k&#160;tomu administračné GUI, kde&#160;sa bude dať všetko pohodlne pozrieť a&#160;naklikať,<li>zrozumiteľnosť technológií pre&#160;iných vývojárov.</ul><p>Chcel by som ešte&#160;zdôrazniť, že&#160;ide o&#160;simulátor a&#160;rovnako, ako v&#160;<em>SoftHSMv2</em> neriešim bezpečnosť ukladania kľúčov a&#160;prenos dát.<h2 id=vyber-technologii-architektury-protokolu>Výber technológií, architektúry, protokolu</h2><p>S experimentálnou fázou som začal v&#160;decembri 2022, keďže nízkoúrovňový driver komunikujúci s&#160;.NET aplikáciou bolo pre&#160;mňa niečo nové, tak namiesto implementácie som strávil niekoľko týždňov výberom technológií a&#160;navrhovaním protokolu. Každej technológii som dal čas a&#160;skúsil si s&#160;ňou implementáciu jednej funkcie, aby&#160;som nebol neskôr prekvapený.<p>Od začiatku som vedel, že&#160;použijem BouncyCastle, lebo&#160;implementuje takmer každý kryptografický algoritmus, na&#160;ktorý si človek spomenie, a&#160;všetko pomocou manažovaného kódu, takže nemá natívne závislosti. Taktiež som vedel, že&#160;administračné GUI musí byť webové, aby&#160;sa dalo ľahko použiť na&#160;serveroch. Navyše som vedel, že&#160;natívna PKCS#11 knižnica nemusí mať rovnakú procesorovú architektúru ako obslužná aplikácia.<p>Na nasledujúcom obrázku sú znázornené jednotlivé predpokladané komponenty systému.<p><img src=images/BouncyHsm/image5.png class=img-center alt="Componente diagram pre BouncyHsm v čase návrhu"><h3 id=vyber-technologii-pre-nativnu-kniznicu>Výber technológií pre&#160;natívnu knižnicu</h3><p>Keďže PKCS#11 knižnica musí byť natívna, tak možné technológie ovplyvnili výber a&#160;návrh protokolu, lebo&#160;ide o&#160;najviac obmedzujúci faktor. No&#160;súčasne som chcel, aby&#160;sa do&#160;vývoja mohli zapojiť aj&#160;iní programátori, tak som spočiatku cielil na&#160;REST (skôr REST-like API s&#160;JSON-om), gRPC alebo&#160;websokety.<p>Ako implementačné jazyky som zvažoval C#, Rust a&#160;C, lebo&#160;dokážu vytvoriť natívnu DLL-ku.<h4 id=vyber-technologie>Výber technológie</h4><p><strong>C#</strong> - od&#160;<em>.NET 7</em> umožňuje pomocou AOT kompilácie vytvoriť natívne aplikácie a&#160;DLL-ky. Ako experiment som si spravil DLL-ku, ktorá načítala dáta z&#160;<a href=https://openweathermap.org/api/one-call-3>OpenWeatherMap</a> a&#160;vrátila ich cez parametre. No&#160;tu som narazil na&#160;problém, že&#160;v tejto verzii nevie exportovať funkcie s&#160;pointermi na&#160;štruktúru (čo sa samozrejme dá obísť pretypovaním), no&#160;aj binárka mala niekoľko MB (v <em>.NET 8</em> boli oba tieto problémy vyriešené) a&#160;na linuxe som sa bál závislostí (OpenSSL).<p><strong>Rust</strong> – skúsil som podobnú implementáciu a&#160;narazil na&#160;iné problémy: hrozne veľa <em>unsafe</em> kódu, neustále konverzie rôznych typov stringov, konverzia číselných typov, ich deklarácie boli problematické (kvôli rôzne veľkým numerickým typom na&#160;rôznych platformách a&#160;architektúrach) a&#160;k tomu rovnaké problémy ako v&#160;predchádzajúcom príklade: binárka pre&#160;Windows mala 12MB a&#160;tiež nejasné závislosti v&#160;knižniciach, plus do&#160;budúcna mi nik negarantuje, že&#160;sa nezmenia.<p><strong>C</strong> – späť ku&#160;základom. Tu si viem jasne definovať závislosti, kód nebude horší ako v&#160;Ruste a&#160;pre PKCS#11 sú už hlavičkové súbory definované. Tak nakoniec som zvolil implementáciu v&#160;C.<p>Následne som začal skúmať možnosti, ktoré mám pri&#160;C implementácii, hlavne transportnú vrstvu protokolu.<h4 id=transportna-vrstva>Transportná vrstva</h4><p><strong>Native messaging</strong> – fungovalo by to tak, že&#160;DLL-ka by si spustila aplikáciu, z&#160;ktorou by komunikovala cez STDIN a&#160;STDOUT, je to jednoduché a&#160;bezpečné riešenie, ktoré navyše izoluje aplikácie a&#160;komunikáciu, no&#160;prináša komplikácie s&#160;tým, že&#160;proces, ktorý&#160;načíta danú DLL-ku musí mať práva spúšťať iné programy a&#160;veľa práce si neušetrím, lebo&#160;aj tak bude treba vmyslieť obdobný komunikačný protokol ako v&#160;ostatných prípadoch.<p><strong>HTTP/S</strong> – na&#160;Windowse záležitosť na&#160;pár riadkov s&#160;<a href=/WinHttp.html>WinHttp</a>, a&#160;to vrátane HTTPS a&#160;trustu, na&#160;linuxe boj s&#160;cURL a&#160;OpenSSL.<p><strong>WebSocket</strong> – podobná situácia, na&#160;Windowse súčasť WinAPI, na&#160;linuxe treťostranné knižnice s&#160;úplne iným programátorským modelom a&#160;prístupom. Navyše pri&#160;websocketoch by som musel riešiť timeouty (aplikácie môžu bežať mesiace), obnovovanie spojenia a&#160;multithreading, čo&#160;by pridalo ďalšiu vrstvu zložitosti.<p><strong>TCP</strong> – nakoniec som skončil s&#160;holým TCP. RPC cez TCP spôsobom, že&#160;pre každý request a&#160;response použijem samostatné spojenie má výhodu v&#160;jednoduchosti, nemusím riešiť lockovanie a&#160;multithreading, na&#160;Windowse a&#160;linuxe majú veľmi podobné API (<em>winsock</em>, <em>posix socket</em>) a&#160;hlavne k&#160;tomu netreba žiadnu externú knižnicu.<h4 id=protokol>Protokol</h4><p>Súčasne s&#160;výberom transportnej vrstvy som vyberal aj&#160;protokol, respektíve, ako budem serializovať dátové štruktúry pri&#160;volaní a&#160;odpovediach zo&#160;serveru. Zvažoval som niekoľko formátov, tu už bolo dôležité, aby&#160;si z&#160;daným formátom poradil aj&#160;.NET (C#).<p><strong>JSON</strong> – JSON som zvažoval ako prvý, hlavne kvôli jeho populárnosti a&#160;tomu, že&#160;preň je plno knižníc pre&#160;jazyk C. Spravil som z&#160;knižnicami niekoľko úspešných experimentov, mali prijateľné API. Síce som musel riešiť prevod do&#160;base64 a&#160;späť, ale&#160;to je vyriešený problém. No&#160;potom som narazil pri&#160;číslach v&#160;JSON-e. Číslo v&#160;JSON-e, je také morské prasiatko – ani&#160;celočíselný typ ani&#160;double. Dané knižnice často implementovali len jedno z&#160;toho. Štandardný JSON, nedokáže preniesť <em>ulong</em> (64-bitový int bez&#160;znamienka), čo&#160;je pri&#160;PKCS#11 stopka. A&#160;kódovať čísla ako stringy sa mi nechcelo.<p><strong>ProtoBuffer</strong> – dúfal som, že&#160;vďaka proto súborom budem môcť vygenerovať serializačný a&#160;deserializačný kód pre&#160;C aj&#160;C#. No&#160;pre C som našiel len jednu aktuálnu knižnicu a&#160;aj tá bola platená.<p><strong>MessagePack</strong> – <a href="https://msgpack.org/">MessagePack</a> je otvorený binárny sterilizačný formát, ktorý&#160;kombinuje kompaktnosť ProtoBufferu a&#160;samopopisnosť JSON-u. To znamená, že&#160;je veľmi malý, relatívne jednoduchý a&#160;nie je potrebné mať k&#160;nemu schému aby&#160;sa dal interpretovať. Navyše binárne dáta nie je potrebné špeciálne enkódvať a&#160;zvláda aj&#160;ulongy, „DateTime“ či&#160;iné dátové typy (vďaka rozšíriteľnosti).<p>Nakoniec som zvolil MessagePack, pretože&#160;som naň našiel <a href=https://github.com/camgunz/cmp>one file knižnicu pre&#160;C</a> (celá knižnica je v&#160;dvoch súboroch – C-éčkový kód a&#160;hlavičkový súbor). Oproti ostatným formátom, ale&#160;nemá štandardnú schému, alebo&#160;OpenAPI pomocou, ktorého by som mohol vygenerovať server a&#160;klienta. To som ale&#160;vyriešil vlastným generátorom. Ten zoberie definíciu RPC (volania a&#160;dátové štruktúry popísané v&#160;YAML súbore). Z&#160;nich vygeneruje pre&#160;každú dátovú štruktúru: C štruktúru, metódy na&#160;serializáciu, deserializáciu a&#160;dealokáciu, pre&#160;C# vygeneruje C# triedu s&#160;príslušnými anotáciami. Pre&#160;RPC volanie je zas vygenerovaná metóda, ktorá dostane vstupnú štruktúru, výstupnú štruktúru a&#160;TCP spojenie, pre&#160;C# sa vygeneruje rozhranie pre&#160;handler (podobný ako používa MediatR), parciálna trieda, ktorú je nutné implementovať na&#160;to aby&#160;sa kód skompiloval a&#160;globálny handler, ktorý&#160;deserializuje request podľa jeho hlavičky a&#160;zavolá konkrétny handler.<p>Samotný protokol sa skladá z&#160;troch častí: hlavičky správy, hlavičky requestu a&#160;tela requestu.<p><strong>Hlavička správy</strong> - je dlhá 8 bajtov. Prvý bajt je identifikátor protokolu <code>0xBC</code>, druhý je číslo verzie protokolu (v tomto prípade <code>0x00</code>), nasledujúce dva bajty sú veľkosť hlavičky requestu kódované v&#160;BE (big endian) a&#160;posledné štyri sú veľkosť tela requestu kódované v&#160;BE.<p><strong>Hlavička requestu</strong> – obsahuje messagepack pole, kde&#160;prvá hodnota je meno operácie, druhá hodnota je <em>tag</em>, ktorý&#160;sa môže použiť na&#160;filtrovanie v&#160;logoch.<p><strong>Telo requestu</strong> – je messagepack objekt, ktorý&#160;je definovaný pre&#160;danú operáciu.<p>Odpoveď má rovnakú štruktúru, ale&#160;hlavička response je len pole z&#160;jednou rezervovanou hodnotou.<p>Pre možnú odlišnú bitovosť nemôžem posielať dáta PKCS#11 funkcií do&#160;dotnetovej aplikácie stranu priamo. Kvôli práci z&#160;nízkoúrovňovou reprezentáciou dát v&#160;PKCS#11 knižnici som priamo v&#160;nej nepoznal kontext a&#160;napríklad pri&#160;PKCS#11 atribútoch neviem v&#160;tejto knižnici určiť ich dátový typ, takže ich kódujem do&#160;všetkých možných (ulong, binárne dáta, string, dátum) a&#160;až dotnetová strana sa rozhodne, ktorú reprezentáciu použije.<h4 id=logovanie>Logovanie</h4><p>Cez premennú prostredia je možné nastaviť úroveň a&#160;ciel logovania. Volil som spôsoby logovania, ktoré zvládne každá aplikácia. Ako defaultné som zvolil zápis chybových logov na&#160;STDERR.<p>Medzi ďalšie možnosti patrí vypnuté logovanie, STDOUT, syslog pre&#160;linux, WinDebug pre&#160;Windows (dá sa sledovať pomocou nástroja <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/">WinDbg</a> zo&#160;SysInternals).<h3 id=vyber-technologie-serveru>Výber technológie serveru</h3><p>Pri výbere technológie serveru to bolo viac menej jasné – ASP.NET Core WebApi, ktorá bude počúvať na&#160;TCP porte pre&#160;pripojenie natívnej knižnice, vystaví RESTové API pre&#160;manažment a&#160;administračné GUI.<p>Túto časť som sa rozhodol robiť v&#160;duchu <em>clean architecture</em> a&#160;teda aplikačná logika vôbec netuší o&#160;úložisku dát, ani&#160;to, že&#160;je volaná cez REST-ové API a&#160;TCP RPC. V&#160;ponímaní tejto architektúry tu máme entity – v&#160;mojom prípade crypto objekty (s celý stromom dedenia ako v&#160;štandarde), prípady použitia mám dvoch druhov – PKCS11 handlery (obsluhujú volania cez PKCS#11 knižnicu) a&#160;UseCases (obsluhujú volania cez REST-ové API). UseCases ale&#160;nie sú riešené na&#160;štýl <em>vertical slice architecture</em> (<em>MediatR</em>) ale&#160;použil som fasády.<p>Na nasledujúcom obrázku je UML diagram implementovaných crypto objektov.<p><img src=images/BouncyHsm/image6.png class=img-center alt="Crypto objekty"><p>S crypto objektmi dosť úspešne pracujem pomocou visitoru, ktorým viem objektom pridať funkcionalitu bez&#160;dedenia (napríklad skonštruovať používateľsky príjemné pomenovanie objektu, alebo&#160;export objektu do&#160;PEM enkódingu).<p>Na projekte som tiež použil knižnice <a href=https://github.com/RicoSuter/NSwag>NSwag</a>, <a href=https://github.com/MessagePack-CSharp/MessagePack-CSharp>MessagePack-CSharp</a>, <a href=https://github.com/bcgit/bc-csharp>BouncyCastle.Cryptography</a>, <a href=https://github.com/domn1995/dunet>Dunet</a>, <a href=https://github.com/Pkcs11Interop/Pkcs11Interop>Pkcs11Interop</a> (autorovi tejto knižnice patrí špeciálna vďaka).<h3 id=vyber-technologie-uloziska>Výber technológie úložiska</h3><p>Pri výbere úložiska som postupoval tak, že&#160;najskôr som si ho implementoval in-memory a&#160;zistil, čo&#160;vlastne potrebujem – niekoľko indexov, takmer žiadne relácie. Pôvodne som chcel použiť relačnú databázu (MsSQL a&#160;Sqlite). Použiť Sqlite by síce znamenalo, použiť niečo, čo&#160;každý pozná, ale&#160;nechcel som pridávať natívne závislosti, tak som použil <a href=https://github.com/mbdavid/LiteDB>LiteDb</a> (zvažoval som aj&#160;<a href=https://github.com/koculu/ZoneTree>ZoneTree</a>) a&#160;pri prevádzke som zatiaľ nenarazil na&#160;problém (pri testoch som skúšal do&#160;nej naliať niekoľko GB dát).<p><em>LiteDB</em> je embeded dokumentová databáza napísaná v&#160;manažovanom C# kóde, kde&#160;API vychádza z&#160;<em>MongoDb</em>. Podporuje indexy, LINQ dopytovanie, GridFs API a&#160;transakcie. Viac som nepotreboval. Výhoda je, že&#160;databázu tvorí jediný súbor, takže ide ľahko prenášať medzi inštanciami. Dobrá vec je aj&#160;to, že&#160;LiteDB má priamo od&#160;tvorcov <a href=https://github.com/mbdavid/LiteDB.Studio>administračný nástroj</a>.<h3 id=vyber-technologie-administracneho-gui>Výber technológie administračného GUI</h3><p>Ako som už spomínal, kvôli tomu, aby&#160;bolo administračné GUI dostupné aj&#160;pri práci na&#160;serveri som sa ho rozhodol spraviť webové.<p>Aby bola aplikácia postavená na&#160;rozšírených technológiách, tak som chcel využiť <em>Vue3</em>, s&#160;ktorým mám dobré skúposti a&#160;ľahko sa s&#160;ním pracuje.<p>No počas prípravnej fázy som v&#160;práci dostal úlohu v&#160;Angularovom projekte zmeniť dva stringy. Ale&#160;mal som novší nodejs ako bol na&#160;projekte, tak som sa pustil do&#160;upgradu projektu. Návod z&#160;oficiálnej stránky nefungoval, lebo&#160;som mal príliš nové nodejs. Takže bolo potrebné všetko spraviť ručne, zdvihnúť Angular, všetky závislosti zo&#160;svojím dependecny hell, typescript,&#8230; A&#160;tak sa z&#160;úlohy, čo&#160;mala trvať päť minút stalo dvojtýždňové trápenie. Preto som si povedal „████ node“ a&#160;rozhodol sa, že&#160;si nebudem robiť zle, administračné GUI proste spravím v&#160;Blazor Webassembly.<p>Frondend je nakoniec postavený na&#160;<a href=https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor>Blazor WebAssembly</a>, REST-ovom API, <a href=https://dotnet.microsoft.com/en-us/apps/aspnet/signalr>SignalR</a> a&#160;<a href="https://getbootstrap.com/">Bootstrape</a>.<h2 id=vyber-licencie>Výber licencie</h2><p>Licenciu som vyberal tak, že&#160;som chcel aby&#160;si hocikto mohol projekt zobrať a&#160;upraviť si ho podľa potreby a&#160;nemusel zverejniť zmeny (niektorí výrobcovia HSM-iek poskytujú dokumentáciu ku&#160;svojej špecifickej funkcionalite pod NDA-čkou), no&#160;súčasne nechcem aby&#160;si na&#160;tomto projekte niekto postavil biznis a&#160;ja z&#160;toho nemal nič. Takže tým odpadli úplne voľné licencie ako <em>MIT</em> a&#160;súčasne aj&#160;nákazlivé ako <em>GPL3</em>. Zostali v&#160;podstate dve licencie <em>BSD 3-Clause</em> a&#160;<em>Apache license 2.0</em>. Zvolil som <em>BSD 3-Clause License</em>, lebo&#160;sa mi nechcelo uvádzať licenciu v&#160;každom zdrojovom súbore projektu.<h2 id=mozna-buduca-praca>Možná budúca práca</h2><p>Do budúcna uvažujem aj&#160;s ďalšou funkcionalitou, ak sa ukáže, že&#160;bude potrebná.<p>Napríklad:<ul><li>nuget pre&#160;integračné testovanie aplikácií (pre <em>MS Test v2</em>, <em>xUnit</em>),<li>proxy, ktorá prevedie TCP RPC na&#160;HTTPS volania na&#160;server,<li>podpora zadávania PIN-u cez <em>„protected path“</em>, to znamená, že&#160;BouncyHsm zobrazí okno, do&#160;ktorého sa zadá PIN (podobne ako <em>Slovenské eID</em>),<li>možnosť vytiahnuť token zo&#160;slotu,<li>podpora novšieho štandardu PKCS#11, keď&#160;bude podporovaný reálnym hardvérom (v súčasnosti sa objavujú len niektoré mechanizmy okolo <em>ED25519</em>),<li>možnosť pridať profily so&#160;zakázanými/povolenými mechanizmami a&#160;určiť maximálnu veľkosť úložiska, pre&#160;simuláciu konkrétnych typov HSM/kariet,<li>implementácia iných úložísk ako LiteDb napríklad nejakej relačnej databázy.</ul><h2 id=co-som-sa-naucil>Čo som sa naučil</h2><p>Tento projekt ma naučil, že&#160;treba byť opatrný pri&#160;výbere knižníc a&#160;protokolu.<p>Tiež som sa naučil, že&#160;špecifikácie nemusia byť úplne jasné a&#160;ku niektorým častiam nenájde príklad použitia ani&#160;google, ani&#160;github a&#160;nepomože ani&#160;umelá inteligencia. No&#160;prenikol som do&#160;tejto špecifikácie hlboko.<p>Aj vďaka tomuto projektu som sa stal <a href=https://www.bouncycastle.org/fr/csharp/contributors.html>kontribútorom BouncyCastle</a>, tým, že&#160;som doň poslal opravy niektorých štruktúr, chýbajúcich drobností, na&#160;ktoré som narazil a&#160;tiež drobné zlepšenia performace. Nebolo to za&#160;deň, ale&#160;bolo potrebné sa do&#160;toho dostať a&#160;tiež codebase tohto projektu nie je malá ani&#160;jednoduchá (keď človek niečo hľadá tak dekompilátor je dobrý kamarát). Odvtedy sledujem issues aj&#160;pull requesty BouncyCastle.<p>Takisto som sa dostal aj&#160;do <em>WinApi</em> a&#160;vývoja pre&#160;linux. Na&#160;škole mi tvrdili, že&#160;na linuxe sa programuje ľahšie, bola to lož. Zatiaľ, čo&#160;Windows ma takmer na&#160;všetko API, tak na&#160;linuxe tu treba buď&#160;čítať z&#160;textového súboru (ktorý môže byť inde a&#160;v inom formáte v&#160;závislosti od&#160;distribúcie a&#160;verzie) alebo&#160;použiť nejakú treťostrannú knižnicu. Linuxu, repektíve <em>glibc</em> tiež chýbajú štandardné bezpečné C-éčkové funkcie, ktoré naopak MSVC vyžaduje (<code>strcpy</code> vs. <code>strcpy_s</code>).<p>Naučil som sa používať <em>make</em>.<p>Vyskúšal som si <em>clean architektúru</em> na&#160;projekte, kde&#160;pomohla s&#160;tým niektoré architektonické rozhodnutia odložiť na&#160;neskôr. Táto architektúra pomohla pre&#160;to, že&#160;doména šla namapovať priamočiaro na&#160;entity, doménovú logiku a&#160;prípady použitia (termín z&#160;<em>Clean architektúry</em>).<h2 id=zaver>Záver</h2><p>Po niekoľkých mesiacoch práce po&#160;večeroch sa mi podarilo vytvoriť simulátor hardvérového zariadenia (HSM), ktorá mi pomáha v&#160;práci a&#160;šetrí nervy. Naučil som sa nové veci a&#160;stal som sa kontribútorom významného otvoreného projektu.<p>Z výsledkom som spokojný, klikať si v&#160;GUI je oveľa pohodlnejšie ako riešiť CLI komandy alebo&#160;obskúrne PKCS#11 nástroje a&#160;hlavne to loguje. Síce GUI vyzerá ako od&#160;backend programátora ale&#160;to stačí.<p><img src=images/BouncyHsm/Slots.jpeg class=img-center alt="Crypto objekty"><p><img src=images/BouncyHsm/SlotDetail.jpeg class=img-center alt="Crypto objekty"><p>Vďaka čistému C-éčku je možné PKCS#11 knižnicu skompilovať na&#160;všetkom a&#160;celý projekt sa mi dokonca podarilo rozbehať na&#160;<em>Raspberry PI Zero 2</em>.<p>No sú aj&#160;veci, ktoré sa mi nepodarili. Ku&#160;časti mechanizmov zo&#160;štandardu nejestvuje zariadenie, ktoré ich implementuje, ani&#160;špecifickejšie zdroje na&#160;internete alebo&#160;príklad kódu, ktorým by som si overil správnosť mojej implementácie. Tak som implementoval tie časti, ktoré sa dali, a&#160;ktoré sa používajú. Pôvodne som chcel ku&#160;BouncyHsm aj&#160;systém pluginov na&#160;rozširovanie funkcionality, ale&#160;to sa nedá riešiť univerzálne, lebo&#160;vendor špecifické veci často vyžadujú zásah aj&#160;do kódu natívnej PKCS#11 knižnice.</div><div class="col-lg-4 col-md-4 hidden-xs hidden-sm"><div class=well><h4>V&#xFD;voj</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/1brc.html>One Billion Rows Challenge</a><li><a href=/MigraciaBlogu.html>Migr&#xE1;cia blogu</a><li><a href=/PostKvantovaKryptografia.html>Post-kvantov&#xE1; kryptografia v C#</a><li><a href=/BouncyHsm.html>Ako som robil BouncyHsm</a><li><a href=/BuildAutomation.html>Pre&#x10D;o pou&#x17E;&#xED;va&#x165; build automation</a><li><a href=/KeyValueDB.html>Ako na Key-Value datab&#xE1;zu</a><li><a href=/RankFunctions.html>MS SQL a RANK funkcie</a><li><a href=/MongoDbVsRavenDb.html>MongoDB vs. RavenDB</a><li><a href=/WinHttp.html>Pou&#x17E;itie WinHTTP</a><li><a href=/BinaryContentInApi.html>ASP.NET Core API a bin&#xE1;rny obsah</a><li><a href=/DevelopingAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>V&#x161;eobecn&#xE9;</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/EzoGenerator.html>Gener&#xE1;tor Ezo textov</a><li><a href=/AlternativnyRecept.html>Propag&#xE1;cia alternat&#xED;vnej medic&#xED;ny</a><li><a href=/VotrelciDavnoveku.html>Votrelci d&#xE1;vnoveku</a><li><a href=/GeneralAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>O mne</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/VyvojarskeOdkazy.html>Moje vyvojarske blogy</a><li><a href=/OMne.html>O mne</a><li><a href=/OMneOdkazy.html>Moja tvorba inde</a><li><a href=/Portfolio.html>Portólio</a></ul></div></div></div></div></div><hr><footer><div class="row no-print"><div class="col-lg-8 col-sm-8"><div class=well><h4>Našli ste chybu, alebo chcete niečo doplniť?</h4><p>Ak ste našli chybu v článu, chcete niečo dopniť, alebo sa vyjadriť k téme, môžete na <a href="https://github.com/harrison314/harrison314.github.io/issues/new?title=Ako%20som%20robil%20BouncyHsm&amp;body=https%3A%2F%2Fharrison314.github.io%2FBouncyHsm.html" target=_blank>Githube otvoriť issue</a>.</div></div></div><div class=row><div class=col-lg-12><p>Copyright &copy; harrison314 2013<span class=on-print> - https://harrison314.github.io/</span></div></div></footer></div><!--Blazor:{"prerenderId":"ee6aa1d8d2e142b78cfc5fb6eeac1ab6"}--><script src=js/jquery.js></script><script src=js/bootstrap.min.js></script><!--Blazor-Server-Component-State:CfDJ8G7p01mvTipOj9seX7mukmtZ/0C+Qx9ofDR4gLGGdQ5xyHx/7TauPVhwE6qPTbcIE4k4TCk9DiigZE+XHTUAS4C8dfURoBzWNPb7rzzDoSD565MEoxw42chHco2DEYX4m3zMmgfdG2i6UCxEMr0HkkBrKr45qbtIjS0R+xyAL4MYqzM+4fjf6UtmtsEQZY0ISTJJECUljfYdfaHvlxNZw+2nLQ7LEy7V8Av3MSV+gly3atbUHSoLASRSBLrlVbd0jySSknhXVectui8C7GFlamGfZlITcDSxDZjP39FEf49hheo3b4m23O798XQhZ6NsZWmtQo+dKaEvnZmlZHKedZF8k09TdGWk0cA3FYSqT0VnQiGwUm8NonnnJokzD/il1jnO6MCanGkaKOgIXww1YF3OLGCPkoistb9FHumaSX5Y5kKF1CnxvnpnksP4EbSxZxnV1MpS7WcOy0PTP5sYtG+2O9fmsEf+lrHzIJWQQUW/AtHNjsgHrJn7h2LIIBMyCSSxycZhTA/Q95OZWEGXqdpd/jNC56tUZWL6fDJwbRkI-->