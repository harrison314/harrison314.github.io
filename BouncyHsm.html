<!DOCTYPE html><html lang=sk><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Xss-Protection content="1; mode=block"><meta http-equiv=X-Content-Type-Options content=nosniff><meta name=viewport content="width=device-width, initial-scale=1"><link rel=alternate type=application/rss+xml title="RSS Feed" href=/feed.rss><link rel=alternate type=application/atom+xml title="Atom Feed" href=/feed.atom><meta name=author content=harrison314><title>Ako som robil BouncyHsm</title><meta property=og:title content="Ako som robil BouncyHsm"><meta property=og:description content="Dôvody, návrh architektúry a vývoj simulátoru HSM a čipových kariet s PKCS#11 rozhraním v .NET-e a Blazore."><meta property=og:url content=https://harrison314.github.io/BouncyHsm.html><meta property=og:image content=https://harrison314.github.io/images/BouncyHsm/media.png><meta name=description content="Dôvody, návrh architektúry a vývoj simulátoru HSM a čipových kariet s PKCS#11 rozhraním v .NET-e a Blazore."><link href=css/bootstrap.min.css rel=stylesheet><link href=css/blog-post.css rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--><link rel=stylesheet href=css/Highiler/vs.css><style>img{max-width:100%}.img-center{display:block;margin-left:auto;margin-right:auto}</style><body><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=index.html>harrison314 blog</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=/All.html>Obsah</a><li><a href=/DevelopingAll.html>Programovanie</a><li><a href=/GeneralAll.html>Všeobecné</a><li><a href=/OMne.html>O mne</a></ul></div></div></nav><div class=container><div class=row><div class="col-lg-8 col-md-8"><h1>Ako som robil BouncyHsm</h1><div class=publishDate>November 2023</div><p>V tomto článku popisujem, ako som robil softvérovú implementáciu HSM-ka (<em>hardware security module</em>), dôvody prečo som sa rozhodol pustiť do&nbsp;projektu, ktorý&nbsp;takmer nik nevyužije, návrhu architektúry, komunikačného protokolu a&nbsp;slepých uličiek, a&nbsp;nakoniec, ako sa vďaka tomu stal kontribútorom <a href=https://github.com/bcgit/bc-csharp>BouncyCastle</a>.<p>Začalo to tak, že&nbsp;som chcel spraviť prototyp systému, ktorý&nbsp;dokáže overiť TOTP (<em><a href=https://www.rfc-editor.org/rfc/rfc6238>Time-based one-time password</a></em>) bezpečne, to znamená, že&nbsp;zdieľané tajomstvo nebude v&nbsp;čitateľnej podobe ani&nbsp;v databáze ani&nbsp;v RAM služby (ako obrana voči memory dumpu) Chcel som na&nbsp;to využiť HSM a&nbsp;jeho existujúci simulátor <em>SoftHSMv2</em>, ale&nbsp;ten nemal podporu potrebných mechanizmov (algoritmov). Vtedy mi došla trpezlivosť a&nbsp;začal som rozmýšľať ako to vyriešiť.<p>Výsledkom je <a href=https://github.com/harrison314/BouncyHsm>BouncyHsm</a>.<h2 id=hsm-pkcs11>HSM, PKCS#11</h2><p>Najskôr trochu nevyhnutnej teórie…<p>HSM je <em>hardware security module</em> – ide o&nbsp;hardvérové zariadenie, ktoré slúži na&nbsp;krytografické operácie a&nbsp;uchovávanie privátnych kľúčov a&nbsp;tajomstiev. Používa sa pre&nbsp;to, že&nbsp;z neho nejde získať privátne kľúče softvérovo ani&nbsp;mechanicky, a&nbsp;chráni pred ich únikom aj&nbsp;v prípade chyby softvéru, aj&nbsp;v prípade odcudzenia zariadenia, ale&nbsp;aj voči takým veciam ako kompromitácia ľudského faktoru (ak sa použije správne).<p>PKCS#11 je platformovo neutrálny štandard pre&nbsp;rozhranie pre&nbsp;prácu s&nbsp;kľúčmi na&nbsp;kryptografických hardvérových zariadeniach ako sú HSM-ká a&nbsp;čipové/smart karty (napríklad <em>Slovenské eID</em>). Ide o&nbsp;API cca. 65 C-éčkových funkcii (exportovaných DLL-kou) a&nbsp;k tomu konštanty a&nbsp;štruktúry. Toto API umožňuje manažment kľúčov a&nbsp;iných objektov, podporuje podpisovanie, šifrovanie, hašovanie,… Často umožňuje použitie RSA, eliptických kriviek, AES šifry, SHA-2 hash funkcií,… Čipové karty podporujú zvyčajne len podpisovanie, zatiaľ čo&nbsp;HSM-ká implementujú omnoho väčšiu časť štandardu.<p>PKCS#11 API má svoje špecifiká, napríklad aplikácia sa musí voči nemu autentifikovať (to sa z&nbsp;bezpečnostných dôvodov robí často ručne). Ide o&nbsp;C API, takže namiesto rozumnej chyby sa vracia len všeobecný chybový kód (niečo ako kategória chyby napr. <code>CKR_GENERAL_ERROR</code>, <code>CKR_ARGUMENTS_BAD</code>, <code>CKR_DEVICE_ERROR</code>, <code>CKR_PIN_INVALID</code>,…) a&nbsp;konkrétnu chybu treba nájsť v&nbsp;logoch obslužného softvéru (dalo by sa povedať ovládača/driveru). Ďalším špecifikom je, že&nbsp;ID-čka nie sú unikátne a&nbsp;viac objektov môže mať zhodné <code>CKA_ID</code>. Objekty sa vyhľadávajú len na&nbsp;presnú zhodu atribútov.<p>Pri vývoji je dobré mať možnosť používať softvérovú náhradu HSM alebo&nbsp;čipovej karty. HSM-ko je pomerne drahá záležitosť, ktorá je zložitá na&nbsp;administráciu, nejde pichnúť do&nbsp;notebooku, čo&nbsp;sa v&nbsp;čase COVID-u a&nbsp;homeofficov ešte&nbsp;skomplikovalo. Zas čipové karty sú kvôli obmedzenému hardvéru pomerne pomalé a&nbsp;majú obmedzený počet zápisov. Obe tieto technológie sa ťažko používajú v&nbsp;unit testoch (technicky sú to integračné testy), hlavne na&nbsp;virtuálnych serveroch.<h3 id=niektore-pojmy-z-pkcs11>Niektoré pojmy z&nbsp;PKCS#11</h3><ul><li><em>slot</em> – reprezentácia čítačky kariet,<li><em>token</em> – reprezentácia čipovej karty,<li><em>crypto objekt</em> – dátová štruktúra na&nbsp;PKCS#11 zariadení, napr. privátny kľúč, verejný kľúč, certifikát, dátový objekt,<li><em>atribút</em> – vlastnosť/property crypto objektu, každý tym crypto objektu má sadu predpísaných vlastností ako <code>CKA_ID</code>, <code>CKA_LABEL</code>, <code>CKA_EC_POINT</code>,…<li><em>privátny objekt</em> – objekt, ktorý&nbsp;ma nastavený atribút <code>CKA_PRIVATE</code> na&nbsp;<code>true</code> a&nbsp;je s&nbsp;ním možné pracovať až po&nbsp;prihlásení do&nbsp;tokenu,<li><em>senzitívny atribút</em> – atribút, ktorý&nbsp;nie je možné z&nbsp;objektu čítať (napr. hodnota privátneho kľúča),<li>mechanizmus – reprezentuje operáciu/algoritmus na&nbsp;PKCS#11 zariadení, napríklad vytvorenie kľúčového páru, typ podpisu (RSA Pkcs1, RSA pss, ECDSA), typ šifrovania (AES, RSA oaep),…</ul><h2 id=existujuce-riesenie-softhsmv2>Existujúce riešenie – SoftHSMv2</h2><p>Softvérová implementácia HSM-ka s&nbsp;PKCS#11 rozhraním už jestvuje, ide o&nbsp;<a href=https://github.com/opendnssec/SoftHSMv2>SohftHSMv2</a>. Niekoľko rokov som ho používal, ale&nbsp;postupne mi pretiekol pohár trpezlivosti.<p>SohftHSMv2 je implementovaný ako natívna knižnica s&nbsp;pár obslužnými programami.<p>Na aké problémy som s&nbsp;ním narazil:<ul><li>malé množstvo podporovaných algoritmov (narazil som keď&nbsp;som potreboval použiť <em>diffie hellman</em> s&nbsp;<em>KDF1</em>, alebo&nbsp;niektoré varianty AES-u),<li>podpora rôznych algoritmov na&nbsp;rôznych platformách (na <em>CentOs 7</em> podporuje inú sadu eliptických kriviek ako na&nbsp;<em>Debian 11</em>),<li>nefunkčné logovanie najmenej od&nbsp;roku 2017 (<a href=https://github.com/opendnssec/SoftHSMv2/issues/598>issue</a> + kody) – na&nbsp;Windowse od&nbsp;začiatku nefunguje logovanie do&nbsp;<em>EventLogu</em>, na&nbsp;linuxových systémoch zas musí logovanie povoliť integrujúca aplikácia do&nbsp;syslogu (logovanie je naozaj dôležité pri&nbsp;vývoji), a&nbsp;tieto problémy neboli doposiaľ opravené,<li>od roku 2020 je nefunkčné CI pre&nbsp;Windows,<li>tým, že&nbsp;ide len o&nbsp;knižnicu, tak si krypto objekty (kľúče) ukladá na&nbsp;súborový systém, to spôsobuje problémy, že&nbsp;keď chcem službe na&nbsp;testovacom prostredí pridať nové kľúče, tak ich nevidí, lebo&nbsp;je spustená pod iným používateľom a&nbsp;treba ručne „hekovať“ súbory kľúčov na&nbsp;disku,<li>ak vaša aplikácia používa inú verziu OpenSSL knižnice ako SoftHSM, pravdepodobne vám pri&nbsp;prvom volaní aplikácia padne,<li>problémové použitie pri&nbsp;unit/integračnom testovaní,<li>netriviálne použitie cez Docker,<li>komplikované použitie cez CMD nástroje (ja rád klikám).</ul><p><img src=images/BouncyHsm/image1.png class=img-center alt="Issue zo SoftHSMv2 - Building on Windows"><br> <img src=images/BouncyHsm/image2.png class=img-center alt="Issue zo SoftHSMv2 - OpenSSL problem"><br> <img src=images/BouncyHsm/image3.png class=img-center alt="Issue zo SoftHSMv2 - Another OpenSSL problem"><br> <img src=images/BouncyHsm/image4.png class=img-center alt="Issue zo SoftHSMv2 - CI is broken"><h2 id=poziadavky-na-bouncyhsm>Požiadavky na&nbsp;BouncyHsm</h2><p>BouncyHsm som sa rozhodol robiť pre&nbsp;to, aby&nbsp;som si vyriešil vyššie spomínané problémy a&nbsp;uľahčil si prácu. Taktiež som chcel dosiahnuť, aby&nbsp;výsledné riešenie bolo „developer frendly“ a&nbsp;ľahko sa nasadzovalo a&nbsp;používalo.<p>Ak som chcel vyriešiť vyššie spomínané problémy, tak od&nbsp;začiatku som vedel, že&nbsp;na kryptografické operácie použijem BouncyCastle, budem sa vyhýbať natívnym závislostiam, a&nbsp;že riešenie bude rozdelené na&nbsp;natívnu PKCS#11 knižnicu a&nbsp;.NET aplikáciu.<p>Z tohto všetkého vychádzajú nasledovné požiadavky:<ul><li>čo najväčšie množstvo kryptografických funkcií zo&nbsp;štandardu <em><a href=https://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/os/pkcs11-curr-v2.40-os.pdf>PKCS#11 v2.40</a></em>,<li>podpora Windowsu, Windows Serveru, niektorých linuxov,<li>podpora x86 a&nbsp;x64 architektúry,<li>rovnaké chovanie na&nbsp;rôznych platformách<li>podpora viac-aplikačného súbežného prístupu cez PKCS#11 knižnicu,<li>jednoduchá inštalácia (rozbalím archív a&nbsp;môžem používať),<li>natívna PKCS#11 knižnica bez&nbsp;závislostí na&nbsp;iných knižniciach (rieši to depenceny hell na&nbsp;linixe),<li>možnosť používať podpisový PIN (ako simuláciu čipových kariet),<li>bohaté logovanie na&nbsp;strane natívnej knižnice aj&nbsp;na strane samotnej aplikácie,<li>možnosť obísť PKCS#11 štandard:<ul><li>pozrieť sa na&nbsp;privátne kryto objekty,<li>pozrieť sa na&nbsp;senzitívne atribúty,<li>možnosť jednoducho importovať P12/PFX, privátny kľúč tak ako keby vznikol v&nbsp;HSM-ku,</ul><li>kvôli použiteľnosti v&nbsp;testoch mať možnosť ovládať BouncyHsm programovo,<li>mať k&nbsp;tomu administračné GUI, kde&nbsp;sa bude dať všetko pohodlne pozrieť a&nbsp;naklikať,<li>zrozumiteľnosť technológií pre&nbsp;iných vývojárov.</ul><p>Chcel by som ešte&nbsp;zdôrazniť, že&nbsp;ide o&nbsp;simulátor a&nbsp;rovnako, ako v&nbsp;<em>SoftHSMv2</em> neriešim bezpečnosť ukladania kľúčov a&nbsp;prenos dát.<h2 id=vyber-technologii-architektury-protokolu>Výber technológií, architektúry, protokolu</h2><p>S experimentálnou fázou som začal v&nbsp;decembri 2022, keďže nízkoúrovňový driver komunikujúci s&nbsp;.NET aplikáciou bolo pre&nbsp;mňa niečo nové, tak namiesto implementácie som strávil niekoľko týždňov výberom technológií a&nbsp;navrhovaním protokolu. Každej technológii som dal čas a&nbsp;skúsil si s&nbsp;ňou implementáciu jednej funkcie, aby&nbsp;som nebol neskôr prekvapený.<p>Od začiatku som vedel, že&nbsp;použijem BouncyCastle, lebo&nbsp;implementuje takmer každý kryptografický algoritmus, na&nbsp;ktorý si človek spomenie, a&nbsp;všetko pomocou manažovaného kódu, takže nemá natívne závislosti. Taktiež som vedel, že&nbsp;administračné GUI musí byť webové, aby&nbsp;sa dalo ľahko použiť na&nbsp;serveroch. Navyše som vedel, že&nbsp;natívna PKCS#11 knižnica nemusí mať rovnakú procesorovú architektúru ako obslužná aplikácia.<p>Na nasledujúcom obrázku sú znázornené jednotlivé predpokladané komponenty systému.<p><img src=images/BouncyHsm/image5.png class=img-center alt="Componente diagram pre BouncyHsm v čase návrhu"><h3 id=vyber-technologii-pre-nativnu-kniznicu>Výber technológií pre&nbsp;natívnu knižnicu</h3><p>Keďže PKCS#11 knižnica musí byť natívna, tak možné technológie ovplyvnili výber a&nbsp;návrh protokolu, lebo&nbsp;ide o&nbsp;najviac obmedzujúci faktor. No&nbsp;súčasne som chcel, aby&nbsp;sa do&nbsp;vývoja mohli zapojiť aj&nbsp;iní programátori, tak som spočiatku cielil na&nbsp;REST (skôr REST-like API s&nbsp;JSON-om), gRPC alebo&nbsp;websokety.<p>Ako implementačné jazyky som zvažoval C#, Rust a&nbsp;C, lebo&nbsp;dokážu vytvoriť natívnu DLL-ku.<h4 id=vyber-technologie>Výber technológie</h4><p><strong>C#</strong> - od&nbsp;<em>.NET 7</em> umožňuje pomocou AOT kompilácie vytvoriť natívne aplikácie a&nbsp;DLL-ky. Ako experiment som si spravil DLL-ku, ktorá načítala dáta z&nbsp;<a href=https://openweathermap.org/api/one-call-3>OpenWeatherMap</a> a&nbsp;vrátila ich cez parametre. No&nbsp;tu som narazil na&nbsp;problém, že&nbsp;v tejto verzii nevie exportovať funkcie s&nbsp;pointermi na&nbsp;štruktúru (čo sa samozrejme dá obísť pretypovaním), no&nbsp;aj binárka mala niekoľko MB (v <em>.NET 8</em> boli oba tieto problémy vyriešené) a&nbsp;na linuxe som sa bál závislostí (OpenSSL).<p><strong>Rust</strong> – skúsil som podobnú implementáciu a&nbsp;narazil na&nbsp;iné problémy: hrozne veľa <em>unsafe</em> kódu, neustále konverzie rôznych typov stringov, konverzia číselných typov, ich deklarácie boli problematické (kvôli rôzne veľkým numerickým typom na&nbsp;rôznych platformách a&nbsp;architektúrach) a&nbsp;k tomu rovnaké problémy ako v&nbsp;predchádzajúcom príklade: binárka pre&nbsp;Windows mala 12MB a&nbsp;tiež nejasné závislosti v&nbsp;knižniciach, plus do&nbsp;budúcna mi nik negarantuje, že&nbsp;sa nezmenia.<p><strong>C</strong> – späť ku&nbsp;základom. Tu si viem jasne definovať závislosti, kód nebude horší ako v&nbsp;Ruste a&nbsp;pre PKCS#11 sú už hlavičkové súbory definované. Tak nakoniec som zvolil implementáciu v&nbsp;C.<p>Následne som začal skúmať možnosti, ktoré mám pri&nbsp;C implementácii, hlavne transportnú vrstvu protokolu.<h4 id=transportna-vrstva>Transportná vrstva</h4><p><strong>Native messaging</strong> – fungovalo by to tak, že&nbsp;DLL-ka by si spustila aplikáciu, z&nbsp;ktorou by komunikovala cez STDIN a&nbsp;STDOUT, je to jednoduché a&nbsp;bezpečné riešenie, ktoré navyše izoluje aplikácie a&nbsp;komunikáciu, no&nbsp;prináša komplikácie s&nbsp;tým, že&nbsp;proces, ktorý&nbsp;načíta danú DLL-ku musí mať práva spúšťať iné programy a&nbsp;veľa práce si neušetrím, lebo&nbsp;aj tak bude treba vmyslieť obdobný komunikačný protokol ako v&nbsp;ostatných prípadoch.<p><strong>HTTP/S</strong> – na&nbsp;Windowse záležitosť na&nbsp;pár riadkov s&nbsp;<a href=/WinHttp.html>WinHttp</a>, a&nbsp;to vrátane HTTPS a&nbsp;trustu, na&nbsp;linuxe boj s&nbsp;cURL a&nbsp;OpenSSL.<p><strong>WebSocket</strong> – podobná situácia, na&nbsp;Windowse súčasť WinAPI, na&nbsp;linuxe treťostranné knižnice s&nbsp;úplne iným programátorským modelom a&nbsp;prístupom. Navyše pri&nbsp;websocketoch by som musel riešiť timeouty (aplikácie môžu bežať mesiace), obnovovanie spojenia a&nbsp;multithreading, čo&nbsp;by pridalo ďalšiu vrstvu zložitosti.<p><strong>TCP</strong> – nakoniec som skončil s&nbsp;holým TCP. RPC cez TCP spôsobom, že&nbsp;pre každý request a&nbsp;response použijem samostatné spojenie má výhodu v&nbsp;jednoduchosti, nemusím riešiť lockovanie a&nbsp;multithreading, na&nbsp;Windowse a&nbsp;linuxe majú veľmi podobné API (<em>winsock</em>, <em>posix socket</em>) a&nbsp;hlavne k&nbsp;tomu netreba žiadnu externú knižnicu.<h4 id=protokol>Protokol</h4><p>Súčasne s&nbsp;výberom transportnej vrstvy som vyberal aj&nbsp;protokol, respektíve, ako budem serializovať dátové štruktúry pri&nbsp;volaní a&nbsp;odpovediach zo&nbsp;serveru. Zvažoval som niekoľko formátov, tu už bolo dôležité, aby&nbsp;si z&nbsp;daným formátom poradil aj&nbsp;.NET (C#).<p><strong>JSON</strong> – JSON som zvažoval ako prvý, hlavne kvôli jeho populárnosti a&nbsp;tomu, že&nbsp;preň je plno knižníc pre&nbsp;jazyk C. Spravil som z&nbsp;knižnicami niekoľko úspešných experimentov, mali prijateľné API. Síce som musel riešiť prevod do&nbsp;base64 a&nbsp;späť, ale&nbsp;to je vyriešený problém. No&nbsp;potom som narazil pri&nbsp;číslach v&nbsp;JSON-e. Číslo v&nbsp;JSON-e, je také morské prasiatko – ani&nbsp;celočíselný typ ani&nbsp;double. Dané knižnice často implementovali len jedno z&nbsp;toho. Štandardný JSON, nedokáže preniesť <em>ulong</em> (64-bitový int bez&nbsp;znamienka), čo&nbsp;je pri&nbsp;PKCS#11 stopka. A&nbsp;kódovať čísla ako stringy sa mi nechcelo.<p><strong>ProtoBuffer</strong> – dúfal som, že&nbsp;vďaka proto súborom budem môcť vygenerovať serializačný a&nbsp;deserializačný kód pre&nbsp;C aj&nbsp;C#. No&nbsp;pre C som našiel len jednu aktuálnu knižnicu a&nbsp;aj tá bola platená.<p><strong>MessagePack</strong> – <a href="https://msgpack.org/">MessagePack</a> je otvorený binárny sterilizačný formát, ktorý&nbsp;kombinuje kompaktnosť ProtoBufferu a&nbsp;samopopisnosť JSON-u. To znamená, že&nbsp;je veľmi malý, relatívne jednoduchý a&nbsp;nie je potrebné mať k&nbsp;nemu schému aby&nbsp;sa dal interpretovať. Navyše binárne dáta nie je potrebné špeciálne enkódvať a&nbsp;zvláda aj&nbsp;ulongy, „DateTime“ či&nbsp;iné dátové typy (vďaka rozšíriteľnosti).<p>Nakoniec som zvolil MessagePack, pretože&nbsp;som naň našiel <a href=https://github.com/camgunz/cmp>one file knižnicu pre&nbsp;C</a> (celá knižnica je v&nbsp;dvoch súboroch – C-éčkový kód a&nbsp;hlavičkový súbor). Oproti ostatným formátom, ale&nbsp;nemá štandardnú schému, alebo&nbsp;OpenAPI pomocou, ktorého by som mohol vygenerovať server a&nbsp;klienta. To som ale&nbsp;vyriešil vlastným generátorom. Ten zoberie definíciu RPC (volania a&nbsp;dátové štruktúry popísané v&nbsp;YAML súbore). Z&nbsp;nich vygeneruje pre&nbsp;každú dátovú štruktúru: C štruktúru, metódy na&nbsp;serializáciu, deserializáciu a&nbsp;dealokáciu, pre&nbsp;C# vygeneruje C# triedu s&nbsp;príslušnými anotáciami. Pre&nbsp;RPC volanie je zas vygenerovaná metóda, ktorá dostane vstupnú štruktúru, výstupnú štruktúru a&nbsp;TCP spojenie, pre&nbsp;C# sa vygeneruje rozhranie pre&nbsp;handler (podobný ako používa MediatR), parciálna trieda, ktorú je nutné implementovať na&nbsp;to aby&nbsp;sa kód skompiloval a&nbsp;globálny handler, ktorý&nbsp;deserializuje request podľa jeho hlavičky a&nbsp;zavolá konkrétny handler.<p>Samotný protokol sa skladá z&nbsp;troch častí: hlavičky správy, hlavičky requestu a&nbsp;tela requestu.<p><strong>Hlavička správy</strong> - je dlhá 8 bajtov. Prvý bajt je identifikátor protokolu <code>0xBC</code>, druhý je číslo verzie protokolu (v tomto prípade <code>0x00</code>), nasledujúce dva bajty sú veľkosť hlavičky requestu kódované v&nbsp;BE (big endian) a&nbsp;posledné štyri sú veľkosť tela requestu kódované v&nbsp;BE.<p><strong>Hlavička requestu</strong> – obsahuje messagepack pole, kde&nbsp;prvá hodnota je meno operácie, druhá hodnota je <em>tag</em>, ktorý&nbsp;sa môže použiť na&nbsp;filtrovanie v&nbsp;logoch.<p><strong>Telo requestu</strong> – je messagepack objekt, ktorý&nbsp;je definovaný pre&nbsp;danú operáciu.<p>Odpoveď má rovnakú štruktúru, ale&nbsp;hlavička response je len pole z&nbsp;jednou rezervovanou hodnotou.<p>Pre možnú odlišnú bitovosť nemôžem posielať dáta PKCS#11 funkcií do&nbsp;dotnetovej aplikácie stranu priamo. Kvôli práci z&nbsp;nízkoúrovňovou reprezentáciou dát v&nbsp;PKCS#11 knižnici som priamo v&nbsp;nej nepoznal kontext a&nbsp;napríklad pri&nbsp;PKCS#11 atribútoch neviem v&nbsp;tejto knižnici určiť ich dátový typ, takže ich kódujem do&nbsp;všetkých možných (ulong, binárne dáta, string, dátum) a&nbsp;až dotnetová strana sa rozhodne, ktorú reprezentáciu použije.<h4 id=logovanie>Logovanie</h4><p>Cez premennú prostredia je možné nastaviť úroveň a&nbsp;ciel logovania. Volil som spôsoby logovania, ktoré zvládne každá aplikácia. Ako defaultné som zvolil zápis chybových logov na&nbsp;STDERR.<p>Medzi ďalšie možnosti patrí vypnuté logovanie, STDOUT, syslog pre&nbsp;linux, WinDebug pre&nbsp;Windows (dá sa sledovať pomocou nástroja <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/">WinDbg</a> zo&nbsp;SysInternals).<h3 id=vyber-technologie-serveru>Výber technológie serveru</h3><p>Pri výbere technológie serveru to bolo viac menej jasné – ASP.NET Core WebApi, ktorá bude počúvať na&nbsp;TCP porte pre&nbsp;pripojenie natívnej knižnice, vystaví RESTové API pre&nbsp;manažment a&nbsp;administračné GUI.<p>Túto časť som sa rozhodol robiť v&nbsp;duchu <em>clean architecture</em> a&nbsp;teda aplikačná logika vôbec netuší o&nbsp;úložisku dát, ani&nbsp;to, že&nbsp;je volaná cez REST-ové API a&nbsp;TCP RPC. V&nbsp;ponímaní tejto architektúry tu máme entity – v&nbsp;mojom prípade crypto objekty (s celý stromom dedenia ako v&nbsp;štandarde), prípady použitia mám dvoch druhov – PKCS11 handlery (obsluhujú volania cez PKCS#11 knižnicu) a&nbsp;UseCases (obsluhujú volania cez REST-ové API). UseCases ale&nbsp;nie sú riešené na&nbsp;štýl <em>vertical slice architecture</em> (<em>MediatR</em>) ale&nbsp;použil som fasády.<p>Na nasledujúcom obrázku je UML diagram implementovaných crypto objektov.<p><img src=images/BouncyHsm/image6.png class=img-center alt="Crypto objekty"><p>S crypto objektmi dosť úspešne pracujem pomocou visitoru, ktorým viem objektom pridať funkcionalitu bez&nbsp;dedenia (napríklad skonštruovať používateľsky príjemné pomenovanie objektu, alebo&nbsp;export objektu do&nbsp;PEM enkódingu).<p>Na projekte som tiež použil knižnice <a href=https://github.com/RicoSuter/NSwag>NSwag</a>, <a href=https://github.com/MessagePack-CSharp/MessagePack-CSharp>MessagePack-CSharp</a>, <a href=https://github.com/bcgit/bc-csharp>BouncyCastle.Cryptography</a>, <a href=https://github.com/domn1995/dunet>Dunet</a>, <a href=https://github.com/Pkcs11Interop/Pkcs11Interop>Pkcs11Interop</a> (autorovi tejto knižnice patrí špeciálna vďaka).<h3 id=vyber-technologie-uloziska>Výber technológie úložiska</h3><p>Pri výbere úložiska som postupoval tak, že&nbsp;najskôr som si ho implementoval in-memory a&nbsp;zistil, čo&nbsp;vlastne potrebujem – niekoľko indexov, takmer žiadne relácie. Pôvodne som chcel použiť relačnú databázu (MsSQL a&nbsp;Sqlite). Použiť Sqlite by síce znamenalo, použiť niečo, čo&nbsp;každý pozná, ale&nbsp;nechcel som pridávať natívne závislosti, tak som použil <a href=https://github.com/mbdavid/LiteDB>LiteDb</a> (zvažoval som aj&nbsp;<a href=https://github.com/koculu/ZoneTree>ZoneTree</a>) a&nbsp;pri prevádzke som zatiaľ nenarazil na&nbsp;problém (pri testoch som skúšal do&nbsp;nej naliať niekoľko GB dát).<p><em>LiteDB</em> je embeded dokumentová databáza napísaná v&nbsp;manažovanom C# kóde, kde&nbsp;API vychádza z&nbsp;<em>MongoDb</em>. Podporuje indexy, LINQ dopytovanie, GridFs API a&nbsp;transakcie. Viac som nepotreboval. Výhoda je, že&nbsp;databázu tvorí jediný súbor, takže ide ľahko prenášať medzi inštanciami. Dobrá vec je aj&nbsp;to, že&nbsp;LiteDB má priamo od&nbsp;tvorcov <a href=https://github.com/mbdavid/LiteDB.Studio>administračný nástroj</a>.<h3 id=vyber-technologie-administracneho-gui>Výber technológie administračného GUI</h3><p>Ako som už spomínal, kvôli tomu, aby&nbsp;bolo administračné GUI dostupné aj&nbsp;pri práci na&nbsp;serveri som sa rozhodol ho spraviť webové.<p>Aby bola aplikácia postavená na&nbsp;rozšírených technológiách som chcel využiť <em>Vue3</em>, s&nbsp;ktorým mám dobré skúposti a&nbsp;ľahko sa s&nbsp;ním pracuje.<p>No počas prípravnej fázy som v&nbsp;práci dostal úlohu v&nbsp;Angularovom projekte zmeniť dva stringy. Ale&nbsp;mal som novší nodejs ako bol na&nbsp;projekte, tak som sa pustil do&nbsp;upgradu projektu. Návod z&nbsp;oficiálnej stránky nefungoval, lebo&nbsp;som mal príliš nové nodejs. Takže bolo potrebné všetko spraviť ručne, zdvihnúť Angular, všetky závislosti zo&nbsp;svojím dependecny hell, typescript,… A&nbsp;tak sa z&nbsp;úlohy, čo&nbsp;mala trvať päť minút stalo dvojtýždňové trápenie. Preto som si povedal „████ node“ a&nbsp;rozhodol sa, že&nbsp;si nebudem robiť zle, administračné GUI proste spravím v&nbsp;Blazor Webassembly.<p>Frondend je nakoniec postavený na&nbsp;<a href=https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor>Blazor WebAssembly</a>, REST-ovom API, <a href=https://dotnet.microsoft.com/en-us/apps/aspnet/signalr>SignalR</a> a&nbsp;<a href="https://getbootstrap.com/">Bootstrape</a>.<h2 id=vyber-licencie>Výber licencie</h2><p>Licenciu som vyberal tak, že&nbsp;som chcel aby&nbsp;si hocikto mohol projekt zobrať a&nbsp;upraviť si ho podľa potreby a&nbsp;nemusel zverejniť zmeny (niektorí výrobcovia HSM-iek poskytujú dokumentáciu ku&nbsp;svojej špecifickej funkcionalite pod NDA-čkou), no&nbsp;súčasne nechcem aby&nbsp;si na&nbsp;tomto projekte niekto postavil biznis a&nbsp;ja z&nbsp;toho nemal nič. Takže tým odpadli úplne voľné licencie ako <em>MIT</em> a&nbsp;súčasne aj&nbsp;nákazlivé ako <em>GPL3</em>. Zostali v&nbsp;podstate dve licencie <em>BSD 3-Clause</em> a&nbsp;<em>Apache license 2.0</em>. Zvolil som <em>BSD 3-Clause License</em>, lebo&nbsp;sa mi nechcelo uvádzať licenciu v&nbsp;každom zdrojovom súbore projektu.<h2 id=mozna-buduca-praca>Možná budúca práca</h2><p>Do budúcna uvažujem aj&nbsp;s ďalšou funkcionalitou, ak sa ukáže, že&nbsp;bude potrebná.<p>Napríklad:<ul><li>nuget pre&nbsp;integračné testovanie aplikácií (pre <em>MS Test v2</em>, <em>xUnit</em>),<li>proxy, ktorá prevedie TCP RPC na&nbsp;HTTPS REST-ove volania na&nbsp;server,<li>podpora zadávania PIN-u cez <em>„protected path“</em>, to znamená, že&nbsp;BouncyHsm zobrazí okno, do&nbsp;ktorého sa zadá PIN (podobne ako <em>Slovenské eID</em>),<li>možnosť vytiahnuť token zo&nbsp;slotu,<li>podpora novšieho štandardu PKCS#11, keď&nbsp;bude podporovaný reálnym hardvérom (v súčasnosti sa objavujú len niektoré algoritmy ako <em>ED25519</em>),<li>možnosť pridať profily so&nbsp;zakázanými/povolenými mechanizmami a&nbsp;určiť maximálnu veľkosť úložiska, pre&nbsp;simuláciu konkrétnych typov HSM/kariet,<li>implementácia iných úložísk ako LiteDb napríklad nejakej relačnej databázy.</ul><h2 id=co-som-sa-naucil>Čo som sa naučil</h2><p>Tento projekt ma naučil, že&nbsp;treba byť opatrný pri&nbsp;výbere knižníc a&nbsp;protokolu.<p>Tiež som sa naučil, že&nbsp;špecifikácie nemusia byť úplne jasné a&nbsp;ku niektorým častiam nenájde príklad použitia ani&nbsp;google, ani&nbsp;github a&nbsp;nepomože ani&nbsp;umelá inteligencia. No&nbsp;prenikol som do&nbsp;tejto špecifikácie hlboko.<p>Aj vďaka tomuto projektu som sa stal <a href=https://www.bouncycastle.org/fr/csharp/contributors.html>kontribútorom BouncyCastle</a>, tým, že&nbsp;som doň poslal opravy niektorých štruktúr, chýbajúcich drobností, na&nbsp;ktoré som narazil a&nbsp;tiež drobné zlepšenia performace. Nebolo to za&nbsp;deň, ale&nbsp;bolo potrebné sa do&nbsp;toho dostať a&nbsp;tiež codebase tohto projektu nie je malá ani&nbsp;jednoduchá (keď človek niečo hľadá tak dekompilátor je dobrý kamarát). Odvtedy sledujem issues aj&nbsp;pull requesty BouncyCastle.<p>Takisto som sa dostal aj&nbsp;do <em>WinApi</em> a&nbsp;vývoja pre&nbsp;linux. Na&nbsp;škole mi tvrdili, že&nbsp;na linuxe sa programuje ľahšie, bola to lož. Zatiaľ, čo&nbsp;Windows ma takmer na&nbsp;všetko API, tak na&nbsp;linuxe tu treba buď&nbsp;čítať z&nbsp;textového súboru (ktorý môže byť inde a&nbsp;v inom formáte v&nbsp;závislosti od&nbsp;distribúcie a&nbsp;verzie) alebo&nbsp;použiť nejakú treťostrannú knižnicu. Linuxu, repektíve <em>glibc</em> tiež chýbajú štandardné bezpečné C-éčkové funkcie, ktoré naopak MSVC vyžaduje (<code>strcpy</code> vs. <code>strcpy_s</code>).<p>Naučil som sa používať <em>make</em>.<p>Vyskúšal som si <em>clean architektúru</em> na&nbsp;projekte, kde&nbsp;pomohla s&nbsp;tým niektoré architektonické rozhodnutia odložiť na&nbsp;neskôr. Táto architektúra pomohla pre&nbsp;to, že&nbsp;doména šla namapovať priamočiaro na&nbsp;entity, doménovú logiku a&nbsp;prípady použitia (termín z&nbsp;<em>Clean architektúry</em>).<h2 id=zaver>Záver</h2><p>Po niekoľkých mesiacoch práce po&nbsp;večeroch sa mi podarilo vytvoriť simulátor hardvérového zariadenia (HSM), ktorá mi pomáha v&nbsp;práci a&nbsp;šetrí nervy. Naučil som sa nové veci a&nbsp;stal som sa kontribútorom významného otvoreného projektu.<p>Z výsledkom som spokojný, klikať si v&nbsp;GUI je oveľa pohodlnejšie ako riešiť CLI komandy alebo&nbsp;obskúrne PKCS#11 nástroje a&nbsp;hlavne to loguje. Síce GUI vyzerá ako od&nbsp;backend programátora ale&nbsp;to stačí.<p><img src=images/BouncyHsm/Slots.jpeg class=img-center alt="Crypto objekty"><p><img src=images/BouncyHsm/SlotDetail.jpeg class=img-center alt="Crypto objekty"><p>Vďaka čistému C-éčku je možné PKCS#11 knižnicu skompilovať na&nbsp;všetkom a&nbsp;celý projekt sa mi dokonca podarilo rozbehať na&nbsp;<em>Raspberry PI Zero 2</em>.<p>No sú aj&nbsp;veci, ktoré sa mi nepodarili. Ku&nbsp;časti mechanizmov zo&nbsp;štandardu nejestvuje zariadenie, ktoré ich implementuje, ani&nbsp;špecifickejšie zdroje na&nbsp;internete alebo&nbsp;príklad kódu, ktorým by som si overil správnosť mojej implementácie. Tak som implementoval tie časti, ktoré sa dali, a&nbsp;ktoré sa používajú. Pôvodne som chcel ku&nbsp;BouncyHsm aj&nbsp;systém pluginov na&nbsp;rozširovanie funkcionality, ale&nbsp;to sa nedá riešiť univerzálne, lebo&nbsp;vendor špecifické veci často vyžadujú zásah aj&nbsp;do kódu natívnej PKCS#11 knižnice.</div><div class="col-lg-4 col-md-4 hidden-xs hidden-sm"><div class=well><h4>Vývoj</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/BouncyHsm.html>Ako som robil BouncyHsm</a><li><a href=/BuildAutomation.html>Prečo používať build automation</a><li><a href=/KeyValueDB.html>Ako na Key-Value databázu</a><li><a href=/RankFunctions.html>MS SQL a RANK funkcie</a><li><a href=/MongoDbVsRavenDb.html>MongoDB vs. RavenDB</a><li><a href=/WinHttp.html>Použitie WinHTTP</a><li><a href=/BinaryContentInApi.html>ASP.NET Core API a binárny obsah</a><li><a href=/PerformaceInNet.html>Meranie performace pre dotnetistov</a><li><a href=/CngApiTips.html>Triky s Windows CNG API</a><li><a href=/InMemoryOltp.html>Experiment s In-Memory OLTP</a><li><a href=/DevelopingAll.html>…</a></ul></div></div></div><div class=well><h4>Všeobecné</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/EzoGenerator.html>Generátor Ezo textov</a><li><a href=/AlternativnyRecept.html>Propagácia alternatívnej medicíny</a><li><a href=/VotrelciDavnoveku.html>Votrelci dávnoveku</a><li><a href=/GeneralAll.html>…</a></ul></div></div></div><div class=well><h4>O mne</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/VyvojarskeOdkazy.html>Moje vyvojarske blogy</a><li><a href=/OMne.html>O mne</a><li><a href=/OMneOdkazy.html>Moja tvorba inde</a><li><a href=/Portfolio.html>Portólio</a></ul></div></div></div></div></div><hr><footer><div class="row no-print"><div class="col-lg-8 col-sm-8"><div class=well><h4>Našli ste chybu, alebo chcete niečo doplniť?</h4><p>Ak ste našli chybu v článu, chcete niečo dopniť, alebo sa vyjadriť k téme, môžete na <a href="https://github.com/harrison314/harrison314.github.io/issues/new?title=Ako%20som%20robil%20BouncyHsm&amp;body=https%3A%2F%2Fharrison314.github.io%2FBouncyHsm.html" target=_blank>Githube otvoriť issue</a>.</div></div></div><div class=row><div class=col-lg-12><p>Copyright © harrison314 2013<span class=on-print> - https://harrison314.github.io/</span></div></div></footer></div><script src=js/jquery.js></script><script src=js/bootstrap.min.js></script>