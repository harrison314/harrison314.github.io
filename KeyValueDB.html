<!DOCTYPE html><html lang=sk><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Xss-Protection content="1; mode=block"><meta http-equiv=X-Content-Type-Options content=nosniff><meta name=viewport content="width=device-width, initial-scale=1"><link rel=alternate type=application/rss+xml title="RSS Feed" href=/feed.rss><link rel=alternate type=application/atom+xml title="Atom Feed" href=/feed.atom><meta name=author content=harrison314><title>Ako na Key-Value databázu</title><meta property=og:title content="Ako na Key-Value databázu"><meta property=og:description content="Ukážka modelovania v key-value databázach."><meta property=og:url content=https://harrison314.github.io/KeyValueDB.html><meta name=description content="Ukážka modelovania v key-value databázach."><link href=css/bootstrap.min.css rel=stylesheet><link href=css/blog-post.css rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--><link rel=stylesheet href=css/Highiler/vs.css><style>img{max-width:100%}.img-center{display:block;margin-left:auto;margin-right:auto}</style><body><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=index.html>harrison314 blog</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=/All.html>Obsah</a><li><a href=/DevelopingAll.html>Programovanie</a><li><a href=/GeneralAll.html>Všeobecné</a><li><a href=/OMne.html>O mne</a></ul></div></div></nav><div class=container><div class=row><div class="col-lg-8 col-md-8"><h1>Ako na Key-Value databázu</h1><div class=publishDate>Máj 2023</div><p>Už nejakú dobu sa zaoberám databázami a&nbsp;nejaký čas som riešil aj&nbsp;vlastné nerelačné úložisko. V&nbsp;tomto blogu chcem zosumarizovať postupy, ako vyriešiť niektoré úlohy pomocou generickej key-value databázy, aj&nbsp;keď mnohé z&nbsp;nich pôsobia dojmom „samozrejmosti“.<p>Pre implementáciu key-value databáz sa najčastejšie používajú <em>B+ stromy</em>, <em>sorted string tabulky</em> (s <em>LSM tree</em>), prípadne <em>skip-list</em>. Všetky tieto implementácie umožňujú nájsť veľmi rýchlo nasledujúci kľúč (v istom zoradení) alebo&nbsp;hľadať podľa prefixu či&nbsp;rozsahu a&nbsp;to je v&nbsp;mnohých nasledujúcich riešeniach potrebné. Databázy založené na&nbsp;<em>hash mapách</em> túto možnosť zvyčajne nemajú.<p><em>V nasledujúcom texte používam syntax, kde&nbsp;<code>key =&gt; value</code> znamená kľúčový pár, ktorý&nbsp;sa uloží v&nbsp;databáze, zátvorky znamenajú N-ticu (binárne serilzovanú N-ticu hodnôt, kde&nbsp;<code>(a, b, c)</code> má prefix <code>(a, b)</code>) a&nbsp;v jednoduchých úvodzovkách sú konštanty. Nasledujúci text vyžaduje aj&nbsp;základné znalosti z&nbsp;relačných databáz.</em><h2 id=pouzitie-prefixov>Použitie prefixov</h2><p>Použitie prefixov kľúčov je základný koncept na&nbsp;oddeľovanie logických celkov v&nbsp;key-value databázach napríklad na&nbsp;určenie typu záznamu, prípade k&nbsp;príslušnosti k&nbsp;inej entite.<pre><code class="language-handlebars hljs"><span class=xml>('data', 'user', user_Id, 'Address') =&gt; user address data
</span></code></pre><p>Takéto usporiadane kľúča hovorí, že&nbsp;sa jedná o&nbsp;dáta (nie index, ani&nbsp;iné pomocné štruktúry) pre&nbsp;používateľa s&nbsp;<code>user_id</code> a&nbsp;položku <code>Address</code>.<p>Následne je možné vymazať všetky údaje k&nbsp;danému používateľovi podľa prefixu <em>id</em> používateľa.<p>Samozrejme veľkosť kľúča je vhodné udržiavať v&nbsp;rozumnej miere.<h2 id=modelovanie-tabuliek>Modelovanie tabuliek</h2><p>Tabuľky (alebo aj&nbsp;<em>column family</em> či&nbsp;<em>wide-column</em> prístup) ide riešiť dvoma spôsobmi. Prvý je taký, že&nbsp;sa použije primárny kľúč ako kľúč, a&nbsp;riadok tabuľky sa serializuje a&nbsp;uloží, ako binárna hodnota.<pre><code class="language-handlebars hljs"><span class=xml>('table', table_name, id) =&gt; (id, given name, surname, date of brith)
</span></code></pre><p>No v&nbsp;tomto prípade nie je možné pracovať so&nbsp;samostatnými hodnotami.<p>Druhý spôsob je ukladania ukladá hodnoty samostatne a&nbsp;je možné s&nbsp;nimi samostatne pracovať bez&nbsp;deserilizácie a&nbsp;serializácie (napríklad ich atomicky inkrementovať alebo&nbsp;vyťiahnuť).<pre><code class="language-handlebars hljs"><span class=xml>('table', table_name, id, 'given name') =&gt; given name
('table', table_name, id, 'surname') =&gt; surname
('table', table_name, id, 'date of brith') =&gt; date of brith
</span></code></pre><h2 id=modelovanie-vektorov>Modelovanie vektorov</h2><p>S modelovaním vektorov je to podobné ako s&nbsp;modelovaním tabuliek. Buď&nbsp;ho uložíme serializovaný alebo&nbsp;po jednotlivých hodnotách, aby&nbsp;s nimi bolo možné pracovať samostatne, či&nbsp;vytiahnuť si len časť vektoru.<pre><code class="language-handlebars hljs"><span class=xml>('vector', vector_name, id) =&gt; (value_1, value_2, value_3,…)
</span></code></pre><p>A druhá varianta.<pre><code class="language-handlebars hljs"><span class=xml>('vector', vector_name, id, index_i) =&gt; value_i
</span></code></pre><h2 id=modelovanie-grafu>Modelovanie grafu</h2><p>Graf sa skladá z&nbsp;vrcholov a&nbsp;hrán medzi vrcholmi. V&nbsp;key-value databáze sa modelujú tak, že&nbsp;vrcholy sú klasické hodnoty so&nbsp;svojim <em>id</em>.<pre><code class="language-handlebars hljs"><span class=xml>('graph', graph_id, 'edge', edge_id) =&gt; edge data

</span></code></pre><p>Orientované hrany majú v&nbsp;kľúči <em>id</em> vrcholu z&nbsp;ktorého vychádzajú do, ktorého vchádzajú a&nbsp;váhy majú v&nbsp;hodnote.<pre><code class="language-handlebars hljs"><span class=xml>('graph', graph_id, 'vertice', edge_from_id, edge_to_id) =&gt; vertice data

</span></code></pre><p>Ak má graf podporovať viacnásobné hrany je ešte&nbsp;pridané <em>id</em> pre&nbsp;samotnú hranu.<p>Pri traverzovaní grafom sa ku&nbsp;aktuálnemu uzlu získajú hrany tak, že&nbsp;sa vyhľadajú podľa prefixu z&nbsp;<em>id</em> aktuálneho uzlu.<h2 id=indexovanie>Indexovanie</h2><p>Indexovanie je spôsob ako uložiť dodatočné informácie tak, aby&nbsp;urýchlili vyhľadávanie a&nbsp;nebolo nutné aby&nbsp;databáza prešla cez všetky dáta. Keďže key-value databázy zvyčajne nemajú sekundárne indexy je ich potrebné modelovať inak.<p>Princíp modelovania indexov je jednoduchý, tiež využíva to, že&nbsp;je možné hľadať podľa prefixu.<p>Ak hodnotu, ktorú indexujeme <code>val1</code>, ktorá sa nachádza v&nbsp;hodnote s&nbsp;<em>id</em>, vytvoríme takýto záznam:<pre><code class="language-handlebars hljs"><span class=xml>('ix', index_name, val1) =&gt; id

</span></code></pre><p>Tak získame unikátny index, no&nbsp;ak chceme indexovať opakujúce sa hodnoty, tak musím do&nbsp;kľúča pridať niečo unikátne a&nbsp;tu sa rovno ponúka použiť <em>id</em> a&nbsp;hodnotu necháme prázdnu.<pre><code class="language-handlebars hljs"><span class=xml>('ix', index_name, val1, id) =&gt; Ø

</span></code></pre><p>A tento koncept môžeme ďalej rozširovať. Napríklad do&nbsp;hodnoty vložiť vybrané dáta s&nbsp;indexovaného záznamu (v SQL svete sú to <em>included columns</em>).<pre><code class="language-handlebars hljs"><span class=xml>('ix', index_name, val1, id) =&gt; (included columns, …)

</span></code></pre><p>Poprípade vytvoriť zložený index, kde&nbsp;sa indexujú viaceré hodnoty.<pre><code class="language-handlebars hljs"><span class=xml>('ix', index_name, val1, val2, id) =&gt; Ø

</span></code></pre><p>Takýto zložený index má rovnaké obmedzenie ako v&nbsp;relačných databázach a&nbsp;to, že&nbsp;samostatne ide vyhľadávať iba podľa prvej hodnoty, ale&nbsp;podľa druhej hodnoty samostatne už nie.<h2 id=modelovanie-casovych-radov>Modelovanie časových radov</h2><p>Časové rady (<em>time series</em>) tvoria hodnoty, ktoré sú usporiadané v&nbsp;čase, ich hodnota je tvorená zvyčajne premennými/vlastnosťami. V&nbsp;key-value databázach idú modelovať rôznymi spôsobmi podľa toho ako ich chceme použiť.<p>Asi najpriamočiarejšie je ako časový údaj použiť rovno timestamp (v milisekndách), vtedy ide vyhľadávať podľa konkrétnych časových údajov. Prípade do&nbsp;kľúča zahrnúť <em>id</em> zdaroja, podľa ktorého chceme filtrovať.<pre><code class="language-handlebars hljs"><span class=xml>('timeserie', timeserie_name,  timestamp) =&gt; (values,…)
</span></code></pre><pre><code class="language-handlebars hljs"><span class=xml>('timeserie', timeserie_name,  timestamp, source_id) =&gt; (values,…)
</span></code></pre><p>Ak ale&nbsp;chceme vyťahovať hodnoty podľa určitých časových období, tak si timestamp rozdelíme na&nbsp;„ľudské“ údaje ako rok, kvartál, mesiac, deň,… tak ide vytiahnuť údaje napríklad pre&nbsp;konkrétny mesiac.<pre><code class="language-handlebars hljs"><span class=xml>('timeserie', timeserie_name,  year, month, day, hout, minute, sec, milisec) =&gt; (values,…)
</span></code></pre><p>Tento model počíta s&nbsp;tým, že&nbsp;v rovnakom čase bude zaznamenaný len jedna hodnota. Ak ich chceme viac musíme kľúč nejakým spôsobom zunikátniť,<h2 id=ukladanie-blob-ov>Ukladanie BLOB-ov</h2><p><em>BLOB</em> (<em>Binary large object data</em>) je proste hocaký blok binárnych dát alebo&nbsp;súbor. Pri&nbsp;key-value databázach ho teoreticky môžeme uložiť ako jednu hodnotu, no&nbsp;pri takom prístupe narážame na&nbsp;maximálnu veľkosť akú je možné uložiť do&nbsp;jednej hodnoty. Taktiež je takto problém tieto dáta vytiahnuť. Pre&nbsp;to je lepšie ich uložiť po&nbsp;malých kúskoch, ktoré sa očíslujú.<pre><code class="language-handlebars hljs"><span class=xml>('blob', blob_name, 'content', 0) =&gt; chunk
('blob', blob_name, 'content', 1) =&gt; chunk
('blob', blob_name, 'content', 2) =&gt; chunk
('blob', blob_name, 'content', 3) =&gt; chunk
('blob', blob_name, 'content', 4) =&gt; chunk
…
('blob', blob_name, 'content', N-1) =&gt; chunk
</span></code></pre><p>A nakoniec ako poslednú hodnotu pridáme informácie o&nbsp;<em>BLOB-e</em>.<pre><code class="language-handlebars hljs"><span class=xml>('blob', blob_name, 'info') =&gt; (chunkCount: N, size: 1024, chunkSize: 512, name: foobar.pdf)`
</span></code></pre><p>To umožní hľadať len kompletne nahrané <em>BLOB-y</em>. Je možné celý zmazať podľa prefixu. A&nbsp;aj vytiahnuť konkrétnu časť, lebo&nbsp;kúsky (chunk-y) majú rovnakú veľkosť (až na&nbsp;posledný).<h2 id=spatial-index>Spatial index</h2><p>Spatial index, alebo&nbsp;aj priestorový index je index, pomocou ktorého ide efektívne vyhľadávať v&nbsp;priestorových dátach (body, geometrické a&nbsp;geografické útvary,…). Typickou úlohou pre&nbsp;tento index je nájsť body do&nbsp;určitej vzdialenosti od&nbsp;iného bodu.<p>V <em>MS SQL</em> je spatial index implementovaný pomocou toho, že&nbsp;priestor sa rozdelí na&nbsp;hierarchickú mriežku, ktorú ide prehľadať podobným princípom ako strom. No&nbsp;v key-value databáze sa používa iný postup – dvojrozmerné body v&nbsp;priestore sa prevedú na&nbsp;jednorozmernú veličinu, ktorá má tú vlastnosť, že&nbsp;blízke hodnoty tejto veličiny implikujú blízkosť pôvodných bodov v&nbsp;dvojrozmernom priestore. Používa sa na&nbsp;to <a href=https://cs.wikipedia.org/wiki/Morton%C5%AFv_rozklad>Mortonov rozklad</a> (<em>Morthon Z-curve</em>, <em>Z-curve order</em>).<p>Pri priestorových útvaroch je treba každý bod tohto útvaru indexovať samostatne.<p>V key-value databázy budeme tento index modelovať nasledovne (pre objekt s&nbsp;<em>id</em>):<pre><code class="language-handlebars hljs"><span class=xml>('ixs', index_name, z_order_value, id) =&gt; (x,y)
</span></code></pre><p>Hodnotu Mortnovho rozkladu získame použitím vhodného zaokrúhlenia a&nbsp;levelu súradníc a&nbsp;pomocou knižnice vypočítame jeho hodnotu (pre .Net to môže byť napríklad <a href=https://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Shape.Fractal.MortonCode.html>NetTopologySiute</a>). V&nbsp;hodnote indexu sú uvedené pôvodné súradnice aby&nbsp;bolo možné jednoducho zistiť, či&nbsp;vyhovujú zadanej podmienke v&nbsp;dopyte. Pomocou Mortnovho rozkladu sa zistí aký&nbsp;rozsah hodnôt sa bude hľadať zo&nbsp;zdaného bodu a&nbsp;vyhľadávanej oblasti. Ten sa v&nbsp;key-value databázy vyhľadá a&nbsp;spracujú sa ich pôvodné hodnoty.<h2 id=zaver>Záver</h2><p>Pomocou key-value databázy ide modelovať mnoho spomenutých vecí. Ktoré sa môžu hodiť, pretože&nbsp;tieto databázy často umožňujú jednoduchú replikáciu a&nbsp;horizontálne škálovanie.<p>Pomocou konkrétnych databáz ide implementovať aj&nbsp;iné dátové modely, ale&nbsp;je pre&nbsp;ne potrebná dodatočná funkcionalita, napríklad pre&nbsp;frontu správ je potrebná atomická funkcia na&nbsp;zmenu hodnoty pre&nbsp;kľúč (napríklad implementovaná pomocou <em>change-vektora</em> alebo&nbsp;kontroly verzie hodnoty).<p>Pri písaní tohto blogu som čerpal hlavne z&nbsp;tutoriálov ku&nbsp;<a href="https://www.foundationdb.org/">FoundationDb</a>, ktorá sa používa ako "podvozok" pre&nbsp;distribuované databázové systémy.</div><div class="col-lg-4 col-md-4 hidden-xs hidden-sm"><div class=well><h4>Vývoj</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/KeyValueDB.html>Ako na Key-Value databázu</a><li><a href=/RankFunctions.html>MS SQL a RANK funkcie</a><li><a href=/MongoDbVsRavenDb.html>MongoDB vs. RavenDB</a><li><a href=/WinHttp.html>Použitie WinHTTP</a><li><a href=/BinaryContentInApi.html>ASP.NET Core API a binárny obsah</a><li><a href=/PerformaceInNet.html>Meranie performace pre dotnetistov</a><li><a href=/CngApiTips.html>Triky s Windows CNG API</a><li><a href=/InMemoryOltp.html>Experiment s In-Memory OLTP</a><li><a href=/CoMaNauciloIot.html>Čo ma naučilo IoT</a><li><a href=/SkEid.html>eID nie je platobná karta</a><li><a href=/DevelopingAll.html>…</a></ul></div></div></div><div class=well><h4>Všeobecné</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/EzoGenerator.html>Generátor Ezo textov</a><li><a href=/AlternativnyRecept.html>Propagácia alternatívnej medicíny</a><li><a href=/VotrelciDavnoveku.html>Votrelci dávnoveku</a><li><a href=/GeneralAll.html>…</a></ul></div></div></div><div class=well><h4>O mne</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/VyvojarskeOdkazy.html>Moje vyvojarske blogy</a><li><a href=/OMne.html>O mne</a><li><a href=/OMneOdkazy.html>Moja tvorba inde</a><li><a href=/Portfolio.html>Portólio</a></ul></div></div></div></div></div><hr><footer><div class=row><div class="col-lg-8 col-sm-8"><div class=well><h4>Našli ste chybu, alebo chcete niečo doplniť?</h4><p>Ak ste našli chybu v článu, chcete niečo dopniť, alebo sa vyjadriť k téme, môžete na <a href="https://github.com/harrison314/harrison314.github.io/issues/new?title=Ako%20na%20Key-Value%20datab%C3%A1zu&amp;body=https%3A%2F%2Fharrison314.github.io%2FKeyValueDB.html" target=_blank>Githube otvoriť issue</a>.</div></div></div><div class=row><div class=col-lg-12><p>Copyright © harrison314 2013</div></div></footer></div><script src=js/jquery.js></script><script src=js/bootstrap.min.js></script>