<!DOCTYPE html><html lang=sk><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Xss-Protection content="1; mode=block"><meta http-equiv=X-Content-Type-Options content=nosniff><meta name=viewport content="width=device-width, initial-scale=1"><link rel=alternate type=application/rss+xml title="RSS Feed" href=feed.rss><meta name=author content=harrison314><meta name=generator content=AspNetStatic><!--Blazor:{"type":"server","prerenderId":"7dd12cac90204159be36e8e49a733caf","key":{"locationHash":"77D12F14A8105320B1AAED6AE7E689DA0EC4483270A645E84079EAA0FFDF550D:5","formattedComponentKey":""},"sequence":0,"descriptor":"CfDJ8G7p01mvTipOj9seX7mukmsAlC0mxvll\u002BN2U4wKDDjjbpbcThs7vLHhwhI23eGoPAdUMH4uHDPWFDgHxAQIk0n3RlmHnhBA74xv3WDmaPw0fIVstzShwxBTpvFz/MFD9va62OQzZ92aRQ8huecvOOQteEtmwlzBnDUDqFigLEc\u002BqAIj42SUAILNsBTk8HhOd59YixdMaFjDW1zU\u002BEX3j4NQfPPjjHQC02CAogiXzFkSE7fRDeG819cpI2A1sZhcPpdgmSxCsejVGgR5vo8JhtrIEdBpBTv/LBk6g5YR76xbywu0142lBmFpDo3QVy4P3zsp1NDLIbon7gknTMAIz3iAPgbUS/R\u002BbqeIwetQCClHt849P7VhIJP5CpNsYKQ565SZK5tCBtp/RUh7pgmIv3VTggkyfo\u002BzIK/N5JR7sttiFpzmNSNcWGpeAz84wmQ0/ER2oMiMLBWygu38f2HMil7bDjn1vLEfj/4fh0b/BE6zNAHQbbM/C\u002BCJOU820Fj2hb4r9tzr9Cn7Ivvmfy6jZ27qn0erf7/59bg1IeWnagYiM/pY2fZNdHHx7s\u002BJkomNa2SFnSF6bmjHyHt\u002BfSrPNMyo="}--><title>Rie&#x161;enie The One Billion Rows Challenge</title><meta property=og:title content="Riešenie The One Billion Rows Challenge"><meta property=og:description content="Riešenie The One Billion Rows Challenge v .NET-e, predstavenie nástrojov na perfomace tuning a rôzne kroky pri riešení tejto úlohy."><meta property=og:url content=https://harrison314.github.io/1brc.html><meta property=og:image content=https://harrison314.github.io/images/1brc/media.png><meta name=description content="Riešenie The One Billion Rows Challenge v .NET-e, predstavenie nástrojov na perfomace tuning a rôzne kroky pri riešení tejto úlohy."><!--Blazor:{"prerenderId":"7dd12cac90204159be36e8e49a733caf"}--><link href=css/bootstrap.min.css rel=stylesheet><link href=css/blog-post.css rel=stylesheet><script type=text/x-mathjax-config>
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script><script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel=stylesheet href=css/Highiler/vs.css><style>img{max-width:100%}.img-center{display:block;margin-left:auto;margin-right:auto}</style><body><!--Blazor:{"type":"server","prerenderId":"0fbfc220c63848bdb1389bfc36b81534","key":{"locationHash":"E66163C4CFF76A7FA22AAEDA8B754AB10710C0C1D42652E9DDB330204231FE18:11","formattedComponentKey":""},"sequence":1,"descriptor":"CfDJ8G7p01mvTipOj9seX7mukmvpWKB6PYhAhN5JPJW6g1OSEHZr85Ovmx2H9ByIfPnhXYahXOEBSO\u002Bsz32YZmhgW3TTDsV02PBy6zpYDD/CZqKkPCOd3mDtSrBqwn0uFAA4r2fY6BAFS\u002B5cENRg8yzPkzh9ZmwhEHDES3kivA3o2KVZ2KBd2SkQmF1og96RYJY2l1anYc7cxBOj1Q320XYDAGuz8ETVLHHPlSAnBDJmieSMak5Huy8efbhjqQGQv2MkVzKZAo6zcAQU5VAfcQkS3MYjjHCOJGY5KKozUcZwDrcrz3/J1dYXx4CpuUPtp3eojmv1MqUgSQ0s8QZ0Zd7n87d65w\u002B1el8tz23nXedMn4IMc6TCzJUJIFqN9IzSRjPsp/z/anyWfoSw9Kr/psGi4AC7Z0lyM\u002BlK8b3RlQCGwYIgbBfsHpUKVFu9E6XnAYAUb5vaBdUUaCY2jRWSOVCpwbm\u002BoIEdZBy7JTRZ6I0B7DD3JZyhWVan7/k5KeDauKXQbii39Xn/ESdQFe502gSXohAgrh9QO6\u002BX0Mbae/IFlnQz"}--><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation><div class=container><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a class=navbar-brand href=index.html>harrison314 blog</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=/All.html>Obsah</a><li><a href=/DevelopingAll.html>Programovanie</a><li><a href=/GeneralAll.html>Všeobecné</a><li><a href=/OMne.html>O mne</a></ul></div></div></nav><div class=container><div class=row><div class="col-lg-8 col-md-8"><h1>Rie&#x161;enie The One Billion Rows Challenge</h1><div class=publishDate>December 2024</div><p>Nedávno som objavil <a href="https://1brc.dev/">The One Billion Rows Challenge</a>. Tento rok som ju uprednostnil pred <a href="https://adventofcode.com/">Advent of code</a>, priniesla mi veľa zábavy.<p>Tento článok je o&#160;zaujímavých nástrojoch na&#160;perofmace tuning, na&#160;ktoré som narazil a&#160;niektorých riešeniach, ktoré som použil a&#160;prišli mi zaujímavé.<p>Síce som videl nejaké existujúce riešenia, ale&#160;šiel som vlastnou cestou, aby&#160;to bolo dobrodružstvo. A&#160;sám som si dal podmienku, že&#160;nechcem používať unsafe kód.<p>Je to doslova primitívna úloha, máme súbor v&#160;UTF-8, v&#160;ktorom je názov miesta a&#160;nameraná teplota (ako desatinné číslo). Úlohou je spraviť program, ktorý&#160;tento súbor prejde a&#160;na konci, pre&#160;každé miesto&#160;vypísať minimálnu, priemernú a&#160;maximálnu teplotu.<p>Po internete kolujú rôzne verzie zadaní (odlišný počet desatinných miest, výstupný formát), ale&#160;principiálne sú si podobné.<p>Príklad formátu vstupného súboru:<pre><code>Hamburg;12.0
Bulawayo;8.9
Palembang;38.8
Hamburg;34.2
Tønsberg;-3.4
St. John's;15.2
Cracow;12.6
&#8230; etc. &#8230;
</code></pre><p>To nie je nič ťažké, hádam v&#160;každom vyššom jazyku ide táto úloha vyriešiť za&#160;5 minút a&#160;ešte si dať kávu. Tak v&#160;čom je tá výzva? V&#160;počte riadkov, je ich 10<sup>9</sup> a&#160;testovací súbor v&#160;mojom prípade mal cez <em>13GB</em>.<p>Pôvodne táto výzva vznikla pre&#160;Javu, keďže sa pri&#160;nej naplno prejaví <em>garbage collector</em>, ale&#160;postupne sa stala obľúbenou aj&#160;pre iné jazyky (C#, Rust, Zig, SQL, awk, PHP,&#8230;).<p>Samozrejme na&#160;každom stroji budú tie časy iné, dokonca aj&#160;niektoré optimalizácie kvôli iným diskom, zberniciam, cache a&#160;procesorom. Mo myslím, že&#160;pri tejto výzve je dôležitejšia cesta, ako cieľ.<h2 id=nastavenie-prostredia-a-nastroje>Nastavenie prostredia a&#160;nástroje</h2><p>Začal som tým, že&#160;som si vytvoril implementáciu pomocou asynchrónneho čítania súboru, proste žiadna optimalizácia. Ku&#160;tomu projekt, ktorý&#160;generoval testovacie súbory (<a href=https://github.com/Vake93/1brc/blob/master/Generator/Program.cs>napríklad takýto</a>), unit test projekt a&#160;benchmark projekt.<p>Uvedené programy mi pomáhali skôr orientačne, pretože&#160;<em>The One Billion Rows Challenge</em> je úloha, ktorá robí len jedinú vec, navyše alokácie som mal v&#160;.NET-e dosť pod kontrolou (kvôli determinizmu do&#160;IL a&#160;JIT-u).<h3 id=benchmarkdotnet>BenchmarkDotNet</h3><p><a href=https://benchmarkdotnet.org/index.html>https://benchmarkdotnet.org/index.html</a><p>Na performace testy som použil <em>BenchmarkDotNet</em> a&#160;súbor s&#160;<em>10 000</em> riadkami. Na&#160;základnú orientáciu stačil, no&#160;neskôr sa ukázal, ako málo presný pri&#160;komplexných programoch. Nie je to chyba <em>BenchmarkDotNet</em>, ale&#160;toho, ako som túto knižnicu použil, je vhodná na&#160;mikro-benchmarking, v&#160;čom je aj&#160;presná, no&#160;ja som ju použil na&#160;beh tela celého programu.<p>Ku koncu sa mi stalo, že&#160;zmena, ktorá vo výsledku na&#160;testovacom súbore s&#160;10<sup>9</sup> riadkami ušetrila 6 sekúnd bola pri&#160;použití <em>BenchmarkDotNet</em> pod štatistickou chybou. No&#160;neskôr som ho používal na&#160;mikro-bechmarking a&#160;na kontrolu alokácii v&#160;kóde.<h3 id=hyperfine>Hyperfine</h3><p><a href=https://github.com/sharkdp/hyperfine>https://github.com/sharkdp/hyperfine</a><p><em>Hyperfine</em> je malý program, ktorý&#160;opakovane spúšťa zadaný program a&#160;vyhodnocuje čas jeho behu.<p>K nemu som si spravil powershell skript, ktorý&#160;skompiluje meraný program klasicky a&#160;potom pomocou AOT a&#160;spustí meranie.<h3 id=dottrace>dotTrace</h3><p><a href="https://www.jetbrains.com/profiler/">https://www.jetbrains.com/profiler/</a><p><em>dotTrace</em> je asi jeden za&#160;najpoužívanejších nástrojov na&#160;perfomace tuning a&#160;hľadaní úzkeho hrdla pre&#160;dotnet aplikácie. Pre&#160;jednotlivcov je zadarmo, pre&#160;firmy platený (údaj z&#160;decembra 2024).<p>Nakoniec som ho nepoužil.<h3 id=visual-studio-profiler>Visual Studio Profiler</h3><p><a href="https://learn.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2022">https://learn.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2022</a><p>Málo ľudí vie, že&#160;priamo vo Visual Studiu (v každej verzii) je profiler nabitý funkcionalitou.<p>Napríklad pomocou snapshotov pamäte a&#160;ich perovaniu ide zistiť, ktoré objekty/triedy spôsobujú pamäťovú náročnosť, alebo&#160;memory leaky.<p>Pri profilovaní CPU zas dokáže ukázať hot paths, teda call stacky na&#160;ktorých procesor spálil najviac času a&#160;sú vhodné na&#160;optimalizáciu. Podobne je to s&#160;alokáciami, async kódom,&#8230;<h3 id=dotnet-trace>dotnet-trace</h3><p><a href=https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace>https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace</a><p><em>dotnet-trace</em> je multiplatformový nástroj pre&#160;zbieranie tracov z&#160;dotnetpvých aplikácií.<p>V mojom prípade som používal:<pre><code>dotnet-trace collect --duration 00:00:20 --format Chromium -- dotnet OneBilionChallenge.dll Data\bilion.txt
</code></pre><p>Príkaz zozbiera trace záznamy a&#160;následne ich ide otvoriť v&#160;Chromiu/Chrome pomocou <a href=chrome:://tracing>chrome:://tracing</a> alebo&#160;v MS Edge pomocou <a href="edge://tracing/">edge://tracing/</a>.<p>Takto ide získať napríklad flame graph, pocty volaní metód a&#160;ďalšie udalosti na&#160;základe ktorých ide získať podrobnosti o&#160;bežaní procesu.<h3 id=codetrack>CodeTrack</h3><p><a href="https://www.getcodetrack.com/">https://www.getcodetrack.com/</a><p><em>CodeTrack</em> je bezplatná alternatíva pre&#160;dotTrace, vizualizuje flame graph, zobrazuje počty volaní a&#160;má jednotlivé volania prepojené s&#160;dekompilovaným kódom. No&#160;napríklad neobsahuje analýzu alokácií a&#160;GC.<p>Aplikácia zvláda aj&#160;.NET Framework, ale&#160;je určená len pre&#160;Windows.<h3 id=ultra>ultra</h3><p><a href=https://github.com/xoofx/ultra>https://github.com/xoofx/ultra</a><p><em>ultra</em> je cmd profiler pre&#160;Windows dostupný vo forme .NET toolu. Rieši aj&#160;JIT, alokácie a&#160;GC. Má bohatší výstup ako <em>dotnet-trace</em>, a&#160;svoju vizualizáciu rieši cez <a href="https://profiler.firefox.com/">https://profiler.firefox.com/</a>.<h2 id=zaujimave-optimalizacie>Zaujímavé optimalizácie</h2><p>Nechcem preberať optimalizácie krok za&#160;krokom, na&#160;to sú iné blogy uvewdené v&#160;zdrojoch, len uvediem zaujímavosti.<p>Začal som s&#160;asychrónnou implementáciou v&#160;<em>.NET 9</em>, ale&#160;tá bola výrazne pomalšia ako synchrónna, čo&#160;dáva zmysel pri&#160;jednovláknovom programe, takže za&#160;naivnú implementáciu považujem synchrónnu, ktorá používa <code>StreamReader.ReadLine()</code>.<p>Na mojom notebooku z&#160;<em>i7-13700H 2.40 GHz, 40GB RAM a&#160;SSD disku</em> spracovanie súboru z&#160;10<sup>9</sup> riadkami (13,8GB) trvalo <em>3 minúty a&#160;43 sekúnd</em>.<p>V ďalších optimalizáciách som sa pokúšal znížiť zbytočné alokácie pri&#160;čítaní súboru po&#160;riadkoch, ale&#160;stále som názov miesta (kľúč v&#160;dictionary) prevádzal na&#160;string. Pre&#160;prístup do&#160;dictionary (<code>Dictionary&lt;string, Data&gt;</code>) som použil <code>CollectionsMarshal.GetValueRefOrAddDefault()</code>.<p>Pri čítaní súboru som zo&#160;<code>System.IO.FileReader</code> prešiel na&#160;<code>System.IO.RandomAccess</code>.<p>Následne som celé riešenie prerobil na&#160;použitie <code>Memory&lt;byte&gt;</code> s&#160;tým, že&#160;som si ku&#160;dictionary spravil wrapper nad <code>Memory&lt;byte&gt;</code> ako štruktúru, ktorá slúži ako kľúč do&#160;dictionary. To malo tú výhodu, že&#160;som vedel volať metódu <code>Dictionary&lt;Utf8Key, Data&gt;.TryGetValue()</code> bez&#160;zbytočnej alokácie. No&#160;malo to nevýhodu, že&#160;som musel pri&#160;pridávaní dát spraviť ďalší lookup do&#160;dictionary pre&#160;<code>Dictionary&lt;Utf8Key, Data&gt;.Add()</code>, to ale&#160;až tak nevadí, lebo&#160;podľa zadania sa v&#160;10<sup>9</sup> riadkoch nachádza maximálne 10<sup>4</sup> unikátnych miest. V&#160;tomto kroku som sa dostal na&#160;<em>1 minútu a&#160;16 sekúnd</em>.<p>Ďalšou optimalizáciou bolo neparsovať teplotu ako double (cez <code>Utf8Parser.TryParse()</code>), ale&#160;napísať si vlastný parser, ktorý&#160;vracal teplotu vynásobenú stovkou, aby&#160;som z&#160;nej spravil integer (<code>Hamburg;34.2</code> → <code>3420</code>). To pomôže hneď v&#160;troch veciach:<ul><li>parsovanie je rýchlejšie, lebo&#160;je prispôsobené na&#160;špecifický formát,<li><code>int Math.Min(int, int)</code> je výrazne rýchlejšie ako <code>double Math.Min(double, double)</code>,<li><code>int Math.Max(int, int)</code> je výrazne rýchlejšie ako <code>double Math.Max(double, double)</code>.</ul><p>Min (a max) pre&#160;integer je dokonca rýchlejšie ako <code>((x &lt; y)? x : y)</code>, pretože&#160;nepoužíva if-y a&#160;procesor nemusí riešiť branch-prediction. Minimum je implementované ako <code>y ^ ((x ^ y) &amp; -(x &lt; y))</code> a&#160;maximum <code>x ^ ((x ^ y) &amp; -(x &lt; y))</code>.<p>Vlastné parsovanie a&#160;nasledujúce zmeny ma dostali na&#160;<em>54 sekúnd</em>.<p>Triedu <code>Data</code> som zmenil na&#160;štruktúru a&#160;namiesto <code>Dictionary&lt;Utf8Key, Data&gt;.TryGetValue()</code> som použil kombináciu metód <code> CollectionsMarshal.GetValueRefOrNullRef()</code> a&#160;<code>Unsafe.IsNullRef()</code> a&#160;tým sa upravil memory layout v&#160;dictionary, čo&#160;ušetrilo 5 sekúnd a&#160;alokácie triedy <code>Data</code>.<div class="lang-cs editor-colors"><div style=color:Black;background-color:White><pre>
<span style=color:Blue>int</span> dataTemperature = Data.Parse(lineData.Temperature.Span);

Utf8Key tmpKey = <span style=color:Blue>new</span> Utf8Key(lineData.Name);
<span style=color:Blue>ref</span> Data refData = <span style=color:Blue>ref</span> CollectionsMarshal.GetValueRefOrNullRef(dictionary, tmpKey);
<span style=color:Blue>if</span> (Unsafe.IsNullRef(<span style=color:Blue>ref</span> refData))
{
    dictionary.Add(tmpKey.Detach(), <span style=color:Blue>new</span> Data(dataTemperature));
}
<span style=color:Blue>else</span>
{
    refData.Add(dataTemperature);
}
</pre></div></div><p>Ďalších 6 sekúnd som získal len tým, že&#160;som si napísal vlastnú jednoduchú hash funkciu pre&#160;kľúč.<p>Na 43 sekúnd som sa následne dostal tak, že&#160;som si všimol, že&#160;vo flame grafoch sa bilónkrát v&#160;dictionary volalo vytvorenie defaultného <code>EqualityComparer&lt;Utf8Key&gt;</code>, tak som dictionary inicializoval na&#160;<em>10000</em> prvkov a&#160;implementoval mu <code>IEqualityComparer&lt;Utf8Key&gt;</code>.<p>Nakoniec som súbor rozdelil na&#160;segmenty a&#160;spracoval ich viacvláknovo podľa počtu jadier procesora a&#160;dostal som sa na&#160;čas okolo 17 sekúnd. Ale&#160;to nie je také zaujímavé.<h2 id=co-v-tomto-pripade-nefungovalo>Čo v&#160;tomto prípade nefungovalo</h2><p>Nikde vyššie nespomínam vektorizáciu a&#160;SIMD, hoci by sa na&#160;parsovanie riadku tieto inštrukcie hodili. Najskôr som skúsil napísať vlastnú implementáciu na&#160;hľadanie nového riadku cez maskovanie <code>Vector&lt;byte&gt;</code> a&#160;potom cez <code>Vector.EqualsAny()</code>, ale&#160;bolo to pomalšie ako <code>MemoryExtensions.IndexOf()</code>.<br> Prečo? Pretože&#160;framework už vektorizáciu masívne používa.<p>Táto úloha vyzerá ako stvorená pre&#160;novinku z&#160;<em>.NET 9</em> – <em>AlternateLookup</em>, ale&#160;ten sa nedá použiť s&#160;<code>CollectionsMarshal.GetValueRefOrAddDefault()</code> takže voči súčasnému stavu by som si nepomohol.<p><em>AOT kompilácia</em> – výsledný beh programu bol vždy o&#160;pár sekúnd pomalší ako klasická framework depend kompilácia.<p><em>ReadyToRun</em> – výsledný beh programu bol pomalší ako AOT skompilovaného programu.<p><em><a href=https://www.nuget.org/packages/CommunityToolkit.HighPerformance>CommunityToolkit.HighPerformance</a></em> – <code>StringPool</code> – myslel som, že&#160;mi zníži alokácie, čo&#160;aj urobil ale&#160;pamäť som vymenil za&#160;procesorový čas na&#160;dodatočné počítanie hashu a&#160;lookap do&#160;dictionary <code>StringPoo</code>-lu.<h2 id=zaver>Záver</h2><p>Bolo zaujímavé rozmýšľať o&#160;tak jednoduchej úlohe z&#160;hľadiska optimalizácie. Bral som to skôr, ako precvičenie práce s&#160;nástrojmi naladenie výkonu a&#160;nástrojov na&#160;optimalizáciu v&#160;dotnete.<p>Pri spracovaní <em>13GB</em> súboru som sa dostal z&#160;času <em>3 minúty 40 sekúnd</em> na&#160;<em>17 sekúnd</em>.<p>Pravdepodobne (podľa už exitujúcich riešení) by som sa dokázal dostať na&#160;oveľa nižší čas ako 17 sekúnd, ale&#160;nechcel som si písať vlastnú implementáciu dictionary ani&#160;používať unsafe kód.<h2 id=zdroje>Zdroje</h2><ol><li><a href="https://blog.ndepend.com/faster-dictionary-in-c/">https://blog.ndepend.com/faster-dictionary-in-c/</a><li><a href="https://blog.ndepend.com/alternate-lookup-for-dictionary-and-hashset-in-net-9/">https://blog.ndepend.com/alternate-lookup-for-dictionary-and-hashset-in-net-9/</a><li><a href="https://www.morling.dev/blog/one-billion-row-challenge/">https://www.morling.dev/blog/one-billion-row-challenge/</a><li><a href="https://www.youtube.com/watch?v=LhhGqNAGQHU&amp;list=PL_nMO-wncU0m3V2_2NmetNDrzTyGLJQAr">https://www.youtube.com/watch?v=LhhGqNAGQHU&amp;list=PL_nMO-wncU0m3V2_2NmetNDrzTyGLJQAr</a><li><a href="https://www.youtube.com/watch?v=HDbtwTsar1Q">https://www.youtube.com/watch?v=HDbtwTsar1Q</a><li><a href="https://www.youtube.com/watch?v=SHGeE_PFA4s">https://www.youtube.com/watch?v=SHGeE_PFA4s</a><li><a href="https://leveluppp.ghost.io/">https://leveluppp.ghost.io/</a><li><a href="https://www.youtube.com/watch?v=aoXSjsJlSp8">https://www.youtube.com/watch?v=aoXSjsJlSp8</a><li><a href=https://github.com/RendleLabs/HiPerfDotNetTalk/tree/main/OneBRC>https://github.com/RendleLabs/HiPerfDotNetTalk/tree/main/OneBRC</a></ol></div><div class="col-lg-4 col-md-4 hidden-xs hidden-sm"><div class=well><h4>V&#xFD;voj</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/1brc.html>One Billion Rows Challenge</a><li><a href=/MigraciaBlogu.html>Migr&#xE1;cia blogu</a><li><a href=/PostKvantovaKryptografia.html>Post-kvantov&#xE1; kryptografia v C#</a><li><a href=/BouncyHsm.html>Ako som robil BouncyHsm</a><li><a href=/BuildAutomation.html>Pre&#x10D;o pou&#x17E;&#xED;va&#x165; build automation</a><li><a href=/KeyValueDB.html>Ako na Key-Value datab&#xE1;zu</a><li><a href=/RankFunctions.html>MS SQL a RANK funkcie</a><li><a href=/MongoDbVsRavenDb.html>MongoDB vs. RavenDB</a><li><a href=/WinHttp.html>Pou&#x17E;itie WinHTTP</a><li><a href=/BinaryContentInApi.html>ASP.NET Core API a bin&#xE1;rny obsah</a><li><a href=/DevelopingAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>V&#x161;eobecn&#xE9;</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/EzoGenerator.html>Gener&#xE1;tor Ezo textov</a><li><a href=/AlternativnyRecept.html>Propag&#xE1;cia alternat&#xED;vnej medic&#xED;ny</a><li><a href=/VotrelciDavnoveku.html>Votrelci d&#xE1;vnoveku</a><li><a href=/GeneralAll.html>&#8230;</a></ul></div></div></div><div class=well><h4>O mne</h4><div class=row><div class=col-lg-12><ul class=list-unstyled><li><a href=/VyvojarskeOdkazy.html>Moje vyvojarske blogy</a><li><a href=/OMne.html>O mne</a><li><a href=/OMneOdkazy.html>Moja tvorba inde</a><li><a href=/Portfolio.html>Portólio</a></ul></div></div></div></div></div><hr><footer><div class="row no-print"><div class="col-lg-8 col-sm-8"><div class=well><h4>Našli ste chybu, alebo chcete niečo doplniť?</h4><p>Ak ste našli chybu v článu, chcete niečo dopniť, alebo sa vyjadriť k téme, môžete na <a href="https://github.com/harrison314/harrison314.github.io/issues/new?title=Rie%C5%A1enie%20The%20One%20Billion%20Rows%20Challenge&amp;body=https%3A%2F%2Fharrison314.github.io%2F1brc.html" target=_blank>Githube otvoriť issue</a>.</div></div></div><div class=row><div class=col-lg-12><p>Copyright &copy; harrison314 2013<span class=on-print> - https://harrison314.github.io/</span></div></div></footer></div><!--Blazor:{"prerenderId":"0fbfc220c63848bdb1389bfc36b81534"}--><script src=js/jquery.js></script><script src=js/bootstrap.min.js></script><!--Blazor-Server-Component-State:CfDJ8G7p01mvTipOj9seX7mukmtDvNER8HoLXfkJ0cPd7D9NjYJKIl1afsFWPKiJOt1pb+bDqsdQeoiBLH8+Wwkg/TNCXoQSTgYgUYufs573DFLy02a78ApG2DEL0jGwxb/h16G+jsSkvxAp1jO0YQTVBDQxm2HP7andcK/qi9gmHVvF3Yq2kMvR50qCG0jpwGz+lLaY5rOlUbHmXAhBa4bFXS8S8Umw05QnqBA2GKM1Zryir5kkIjz+DhvkYPOCr/K5INOGVWs+4S2Ps0AmKRbBmkYaVov5malskVLoSm9f3IHGCkWqR6N9Ku71jE+DNbL4O8fTfzq9zp6Z3awntdHfJLjiKe1YW9nHXVE+wJyqSoFsA3p2jd7WqjRKJ1hlDB9h+lZCPqXs+HnTql6Pnp+9E/MpUwGmNH9OdEgPyqIfHsllMDGvOdTUY2eniLU//5qEaOMHdObWe8glWVNBGReXh+T5wyNr2+gYtm+6hPjYHfaEqrZg7Q1j5lJcaO4HS7Y3IHV+og4xcvo3iFe0b5rY1BSOWNRYKPUKT3fBSS41dYqb-->